## **소수**

### **◾ 개념**

소수는 ‘양의 약수를 두 개만 가지는 자연수’


### **◾ 에라토스테네스의 체**

고대 그리스 수학자 에라토스테네스가 만들어 낸 방법으로, 소수(Prime Number)를 판별해주는 알고리즘. 마치 체로 치듯이 수를 걸러낸다고 해서 이런 이름이 붙게 되었다. n까지의 소수를 알고 싶을 때, n^1/2 이하의 수의 배수만 지우면 된다

1. 원하는 숫자까지의 값을 초기화한다.
2. 2부터 시작해서 특정 숫자의 배수에 해당하는 숫자들을 모두 지운다. (자기 자신을 제외한 배수를 지운다.)
3. 이미 지워진 숫자의 경우 건너뛰고 진행한다.

```java
public class Solution {

	//120까지의 소수 구해보기
	static boolean prime[] = new boolean[121];
    
    public static void main(String[] args) throws Exception{
		
        // 구하고자 하는 숫자 범위
        int N = 120;
        
        // 소수는 false
        // 1은 소수가 아니므로 제외
        prime[0] = prime[1] = true;
        
        for(int i=2; i*i<=N; i++){
        	// prime[i]가 소수라면
            if(!prime[i]){
            	// prime[j] 소수가 아닌 표시
            	for(int j=i*i; j<=N; j=j+i) prime[j] = true;                
            }        
        }    
        
        // 소수 출력
        for(int i=1; i<=N; i++){
        	if(!prime[i]) System.out.print(i+" ");        
        }
    }
}
```

### **◾ 시간 복잡도**

기본 로직의 시간복잡도 : O(N*N^(1/2)) </br>
에라토스테네스의 체의 시간복잡도 : O(Nlog(logN)) </br>
  → 가장 빠르고 정확하게 소수를 구하는 알고리즘

## **다이나믹 프로그래밍 DP**

### **◾ 개념**

큰 문제를 작은 문제로 나눠 푸는 방법. 모든 작은 문제들을 한 번만 풀고, 이를 어딘가에 메모해 놓는다. </br> 다시 그보다 큰 문제를 풀 때 똑같은 문제가 나타나면 앞서 메모한 작은 문제의 결과값을 이용한다. </br>

즉 답을 여러 번 계산하는 대신 한 번만 계산한다 → 재활용을 통해 속도 향상


### **◾ 메모이제이션(Memoization) 이란?**

: 한 번 구한 결과를 어딘가에 저장해두고, 같은 정보가 필요할 때는 이미 구한 결과를 가져오는 것을 통해 속도 단축 </br>(다이나믹 프로그래밍과는 별도의 개념이다. 한 번 계산된 결과를 어딘가에 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음)

- 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시킬 수 있음

- 다이나믹 프로그래밍을 구현하는 방법 중 한 종류임

- 예시) 피보나치함수를 푸는방법으로 재귀함수를 이용한 방법이있지만 느리다. 수가 커질수록 엄청난 스택이쌓인다. — 이런 단점을 메모이제이션으로 해결

### **◾ 분할 정복 방식과의 차이점**

작은 문제가 중복이 일어나는지 일어나지 않는지에 차이점! </br>
분할정복은 큰 문제를 해결하기 어려워 단지 작은 문제로 나누어 푸는 방법이다. 작은 문제들이 반복되지는 않는다

### **◾ 기본 로직 (다이나믹을 푸는 두 가지 방식)**

**1. Top-down**

> 큰 문제를 해결하기 위해 작은 문제 호출. 재귀함수로 보통 구현됨
> 
1. 문제를 작은 문제로 나눈다.
2. 작은 문제들을 푼다.
3. 작은 문제들의 답으로 전체 문제를 푼다.



**2. Bottom-up**

> 작은 문제부터 차근차근 답을 도출하는 방식. 반복문 이용
> 
1. 가장 작은 문제부터 푼다.
2. 문제의 크기를 점점 크게 만들어서 전체문제를 푼다.



### **참고**

[에라토스테네스의 체](https://firework-ham.tistory.com/8)

[에라토스테네스의 체](https://choheeis.github.io/newblog//articles/2020-04/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4#:~:text=%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4%EB%8A%94%20%EC%8B%9C%EA%B0%84,%EC%86%8C%EC%88%98%EB%A5%BC%20%EA%B5%AC%ED%95%98%EB%8A%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4).

[다이나믹 프로그래밍](https://blex.me/@mildsalmon/chap-8-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90)

[다이나믹 프로그래밍](https://galid1.tistory.com/507)

