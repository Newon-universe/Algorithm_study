## 이분 탐색 / 이진 탐색 (Binary Search)
### ① 개념
**정렬**된 배열 또는 리스트에 적합한 고속 탐색 알고리즘  

### ② 구현과정 및 구현조건
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FG7wHv%2FbtqV0D9Zn52%2FIrArSq3Au3Qlkd2ja1166k%2Fimg.png" width="350" />

#### 구현조건
* 저장된 모든 데이터는 **정렬** 되어있어야 한다

#### 구현과정
* 탐색 대상이 되는 데이터들이 array[low] 부터 array[high]에 들어있다고 가정
  * 처음 low 에는 0번 인덱스의 값, high 에는 n-1번 인덱스 값
* low 와 high 값에 의거해 중간(mid) 값은 **(low + high)/2**
* array[mid] 값과 구하고자 하는 **key 값을 비교**
  * key > mid : 구하고자 하는 값이 중간값보다 높다면 low 를 mid+1 로 만들어줌 (왼쪽 반을 버림)
  * key < mid : 구하고자 하는 값이 중간값보다 낮다면 high 를 mid-1 로 만들어줌 (오른쪽 반을 버림)
  * key == mid : 구하고자 하는 값을 찾음, 중간값 리턴
* **low > high** 될 때까지 앞의 과정을 반복하며 구하고자 하는 값을 찾아감

</br>

### ③ 코드(반복문)
> Java
```java
public static boolean binarySearch(int key) {
  int low = 0;
  int high = 정렬된_배열.length - 1;
  
  while (start <= end) {
      int mid = (low + high) / 2;
      if(정렬된_배열[mid] == card) return true; 　　　// key 발견 시 true 반환
      else if(정렬된_배열[mid] < key) low = mid + 1;
      else high = mid - 1;
  }
  return false;
}
```

### ④ 코드(재귀)
> Java
```java
public static int binarySearch(int key, int low, int high) {
  int mid;
  
  if (start <= end) {
      mid = (low + high) / 2;
      if(key == 정렬된_배열[mid])     　　　　　　　// key 발견 시 값 반환
          return mid;
      else if(key < 정렬된_배열[mid]) 　　　　　　　// 왼쪽 arr[0] 부터 arr[mid-1] 에서의 탐색
          return binarySearch(key, low, mid - 1);
      else                           　　　　　　　// 오른쪽 arr[mid+1] 부터 arr[high] 에서의 탐색
          return binarySearch(key, mid + 1, high);
  }
  return false;
}
```

</br>

### ⑤ 시간복잡도  
▷ **O(lgN)**   

알고리즘은 탐색을 반복할 때마다 탐색 범위를 반으로 줄인다.  
이러한 탐색 범위가 더 이상 줄일 수 없는 1이 될 때의 탐색 횟수를 k라고 하면, 아래 표와 같다.  

|비교|범위|
|:--:|:--:|
|q0|n|
|1|n/2|
|2|n/4|
|...|...|
|k|n/2^k|

표의 마지막 행에서 n/2^k = 1 이므로, k = log2n 임을 알 수 있다.  
따라서 이진 탐색의 시간 복잡도는 **O(lgN)** 이 된다.  

<br/>

### ⑥ 장단점  
* **장점** : 선형 탐색과 비교하여 탐색 시간이 빠르다
* **단점** : 정렬된 리스트에서만 사용될 수 있다.

<br/>

## 정렬
정렬이란, 데이터를 **특정한 기준**에 따라 순서대로 나열하는 것  
정렬 알고리즘으로 데이터를 정렬하면 이진 탐색(Binary Search)이 가능해진다.  
즉, 이진 탐색의 전처리 과정이기도 하다.  

### ① 정렬의 종류와 개념
#### ▷ 선택정렬  
*Selection Sort*  
말그대로 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘  
데이터를 비교하면서 찾기 때문에 **비교 정렬** 이며,  
정렬의 대상이 되는 데이터 외에 추가적 공간을 필요로 하지 않기에 **제자리 정렬(in-place-sort)** 이기도 하다.  
또한 중복된 값이 입력 순서와 동일하지 않게 정렬되는 **불안정 정렬(unstable-sort)** 이다.

#### ▷ 삽입정렬  
*Insertion Sort*  
현재 비교하고자 하는 **타겟** 과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 방식  
데이터를 비교하면서 찾기 때문에 **비교 정렬** 이며,  
정렬의 대상이 되는 데이터 외에 추가적 공간을 필요로 하지 않기에 **제자리 정렬(in-place-sort)** 이기도 하다.  
또한 중복된 값을 입력 순서와 동일하게 정렬하는 **안정 정렬(stable-sort)** 이다.

#### ▷ 버블정렬  
*Bubble Sort*  
두개의 인접한 원소를 비교하여 정렬하는 방식  
데이터를 비교하면서 찾기 때문에 **비교 정렬** 이며,  
정렬의 대상이 되는 데이터 외에 추가적 공간을 필요로 하지 않기에 **제자리 정렬(in-place-sort)** 이기도 하다.  
또한 중복된 값을 입력 순서와 동일하게 정렬하는 **안정 정렬(stable-sort)** 이다.


### ② 구현과정 및 구현조건
#### ▷ 선택정렬  
* 주어진 리스트에서 최솟값을 찾는다.
* 최솟값을 맨 앞 자리의 값과 교환한다.
* 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcO4e4B%2FbtqNhbVoPkl%2F2ZLzCObztYU79fb9dkns8K%2Fimg.png" width="450" />

#### ▷ 삽입정렬  
* 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다.  
  💡 첫번째 타겟은 **두번째 원소** 부터 시작한다.
* 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
* 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKRty3%2FbtqOKXNAGUh%2FIfdJIJDJWeAfbNDHQ6eyh0%2Fimg.png" width="450" />

#### ▷ 버블정렬  
* 앞에서부터 현재 원소와 다음 원소를 비교한다.
* 현재 원소가 다음 원소보다 크면 원소를 교환한다.
* 다음 원소로 이동하여 해당 원소와 그 다음 원소를 비교한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdfQeBw%2FbtqT1848T64%2FH5D9U4z8dhELfRTkfk2k30%2Fimg.png" width="450" />


### ③ 코드(반복문)
> Java
```java
// 선택정렬
public class Selection_Sort {
    
    public static void main(String[] args) {
        
        int []arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};
        
        int minIndex = 0; //가장 적은 원소의 인덱스
        
        for(int i=0; i < arr.length; i++){
            for(int j=i+1 ; j < arr.length; j++){
                if(arr[minIndex] > arr[j])
                    minIndex = j;
            }
            
            //스와프
            int tmp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = tmp;
        }
        System.out.println(Arrays.toString(arr));
    }
}

// 삽입정렬
public class Insertion_Sort {
    
    public static void main(String[] args) {
        
        int []arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};
        
        
        for(int i=1; i < arr.length; i++){
            for(int j=i ; j >= 1; j--){
                
                if(arr[j] < arr[j-1]){  //한 칸씩 왼쪽으로 이동
                    int tmp = arr[j];
                    arr[j] = arr[j-1];
                    arr[j-1] = tmp;
                }else break;  //자기보다 작은 데이터를 만나면 그 위치에서 멈춤
                
            }
        }
        System.out.println(Arrays.toString(arr));
    }

// 버블정렬
public class Bubble_Sort {
 
  public static void bubble_sort(int[] a) {
   bubble_sort(a, a.length);
  }

  private static void bubble_sort(int[] a, int size) {

   // round는 배열 크기 - 1 만큼 진행됨 
   for(int i = 1; i < size; i++) {

    // 각 라운드별 비교횟수는 배열 크기의 현재 라운드를 뺀 만큼 비교함
    for(int j = 0; j < size - i; j++) {

     /*
      *  현재 원소가 다음 원소보다 클 경우
      *  서로 원소의 위치를 교환한다. 
      */
     if(a[j] > a [j + 1]) {
      swap(a, j, j + 1);
     }
    }
   }
  }

  private static void swap(int[] a, int i, int j) {
   int temp = a[i];
   a[i] = a[j];
   a[j] = temp;
  }
}
```

### ⑤ 각 정렬방법의 시간복잡도
#### ▷ 선택정렬 : O(N²)
N-1 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.  
또한 매번 가장 작은 수를 찾기 위해 비교 연산이 필요하다.  
즉, 연산 횟수는 N + (N-1) + (N-2) + .. + 2 이고, 근사치로 **N * (N+1) / 2** 번의 연산을 수행한다.  

#### ▷ 삽입정렬 : O(N), O(N²)  
타겟 숫자가 이전 숫자보다 크기 전까지 반복되기 때문에,  
이미 정렬이 되어있는 경우 항상 타겟 숫자가 이전 숫자보다 크다.  
즉, 값을 N번만 비교하기에 **최선의 경우 O(N)** 의 시간복잡도를 지닌다.  

반대로 최악의 경우에 타겟 숫자가 이전 숫자보다 항상 작기에 결국 N번째 숫자에 대해 N-1번을 비교해야 한다.  
그렇기에 **최악의 경우는 O(N²)** 의 시간복잡도를 지닌다.  

#### ▷ 버블정렬 : O(N²)
정렬이 되어 있든 안되어 있든 N개의 input 이 있을 때 N개에 대해 각각 N번,  
즉 for문을 2번 돌기에 (교환이 일어나지 않더라도 비교는 계속 진행하기 때문에)  
최상ㆍ최악ㆍ평균의 경우 **모두 O(N²)의 시간복잡도** 를 지닌다.

<br/>

### ⑦ 참고
[Java / 이진탐색 구현과 시간복잡도](https://minhamina.tistory.com/127)  
[Java / 선택 정렬 (Selection Sort)](https://st-lab.tistory.com/168?category=892973)  
[Java / 삽입 정렬 (Insertion Sort)](https://st-lab.tistory.com/179?category=892973)  
[Java / 버블 정렬 (Bubble Sort)](https://st-lab.tistory.com/195?category=892973)  
