## 트리
<img src="https://media.vlpt.us/images/roro/post/451ac29b-42f1-491b-9599-1459355b421b/Untitled.png" width="450" />

### 개념
*Undirected Acyclic Connected Graph*  
무방향이면서 사이클이 없는 **연결 그래프**  
V개의 노드를 가진 트리는 V-1 개의 간선을 지녔으며, 임의의 두 노드를 연결하는 simple path 가 유일하다.  
> simple path = 노드가 중복해서 나오지 않는 경로  

### 트리 관련 용어
* 노드(node) : 트리의 구성 요소로, 트리는 한개 이상의 노드로 이루어진 유한 집합
* 루트(root) : 가장 상위 노드로 하나의 트리에는 하나의 루트가 존재함
* 서브 트리(subtree) : 루트 노드를 제외한 나머지 노드
* 리프(leaf) : 트리의 가장 하단에 위치한 노드
* 부모(parent) : 어떤 노드에서 가지로 연결된 위쪽 노드로, 노드는 1개의 부모를 가짐
* 자식(child) : 어떤 노드로부터 가지로 연결된 아래쪽 노드로, 노드를 여러 자식을 가질 수 있음
* 형제(sibling) : 같은 부모를 가지는 노드
* 차수(degree) : 노드가 가지고 있는 자식 노드의 개수
* 레벨(level) : 각 층에 번호를 매기는 것으로, 루트의 레벨은 1이며 내려갈 때마다 레벨이 증가함

### 트리와 그래프의 차이
트리는 순환 구조를 갖지 않는다.  
그래프는 단방향ㆍ양방향 모두 가리킬 수 있는 반면 트리는 단방향 (부모 -> 자식) 뿐이다.  
또한 트리는 하나의 부모만을 가지고, 루트 또한 하나다.

</br>

## 이진트리
### 개념
*Binary tree*  
모든 노드가 2개의 서브 트리를 가지고 있는 트리로, 서브 트리 또한 이진 트리여야 한다.  
서브 트리는 공집합일 수 있으며, 즉 0~2개의 자식 노드가 존재할 수 있다.  
또한 서브 트리 간의 순서가 존재해 왼쪽ㆍ오른쪽 서브 트리는 구별된다.   

### 이진트리 분류
<img src="https://user-images.githubusercontent.com/48541984/138961559-899f2dcb-b40a-43b6-aabb-2604441812d9.png" width="460" />

#### ▪ 완전 이진 트리
*Complete Binary Tree*  
높이가 k 일 때 **레벨 1부터 k-1 까지**는 노드가 채워져 있고,  
마지막 레벨 k에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져 있는 이진 트리다.  
마지막 레벨에서는 노드가 가득 차지 않아도 되지만, 중간에 빈 곳이 있으면 안 된다.  

#### ▪ 포화 이진 트리
*Full Binary Tree*  
각 레벨에 노드가 꽉 차 있는 이진 트리로, 각 노드에 레벨 단위로  
왼쪽에서 오른쪽으로 번호를 붙일 수 있다. (부여된 번호는 항상 일정하다!)  

#### ▪ 이진 트리 간 관계 🌲
이진 트리 ⊃ 완전 이진 트리 ⊃ 포화 이진 트리

### 트리 표현법
#### ▪ 배열 표현법
주로 포화 이진 트리나 완전 이진 트리의 경우 많이 사용되는 방식이다.  
배열을 사용하면 노드 접근이 빠르고 구현이 용이하다는 장점이 있지만,  
편향 이진트리의 경우 많은 공간이 낭비될 수 있고 배열 크기 이상 노드를 추가할 수 없다.  

아래와 같은 **이진 트리의 속성**으로 배열로 표현이 가능하다.  
<img src="https://user-images.githubusercontent.com/48541984/138964602-842774cd-16dd-4c46-bc46-98a4151754b3.png" width="450" />

> 루트 노드의 인덱스 i가 0인 경우,
* 노드 i 에 왼쪽 자식은 2*(i+1) 번째 노드
* 노드 i 에 오른쪽 자식은 2*(i+2) 번째 노드
* 노드 i 에 부모는 (i-1)/2 번째 노드

#### ▪ 링크 표현법
링크 표현법에서는 노드가 구조체로 표현되고, 각 노드가 가진 **포인터**를 이용해 노드와 노드를 연결하는 방식이다.  
데이터 필드 1개와 양쪽 자식 노드 각각을 가리키는 2개의 포인터 필드를 지닌다.  
</br>
<img src="https://user-images.githubusercontent.com/48541984/138964877-2c68b46a-ae62-4a79-a8a9-738307977811.png" width="450" />

</br>

## 순회

### 개념
이진 트리를 순회한다는 것은 이진 트리에 속하는 모든 노드를 한 번씩 방문하여  
노드가 가지고 있는 **데이터를 목적에 맞게 처리하는 것**을 의미한다.  
트리를 사용하는 목적은 트리의 노드에 자료를 저장하고 필요에 따라서 이 자료를 처리하기 위함이다.  

### 종류
> *V=루트 , L=왼쪽 , R=오른쪽*  
#### ▪ 전회 순회 (preorder / VLR)
```java
preorder(x) {
    if x != NULL
        then print x-> data;
        preorder(x->left);
        preorder(x->right);
}
```

#### ▪ 중위 순회 (inorder / LVR)
```java
inorder(x) {
    if x != NULL
        then inorder(x->left);
        print(x->data);
        inorder(x->right);
}
```

#### ▪ 후위 순회 (postorder / LRV)
```java
postorder(x) {
    if x != NULL
        then postorder(x->left);
        postorder(x->right);
        print x->data;
}
```

</br>

## 그리디 알고리즘

### 개념
*Greedy, 욕심쟁이 👧 알고리즘*  
매 선택에서 현재 가장 최적인 답을 선택해 전체 적합한 결과를 도출하는 알고리즘  
**관찰**을 통해 탐색 범위를 줄이는 알고리즘  

### 사용조건
#### ▪ 탐욕 선택 조건
*Greedy Choice Property*  
이전의 선택이 이후에 영향을 주지 않는다.

#### ▪ 최적 부분 조건
*Optimal Substructure*  
부분 문제의 최적 결과가 전체에도  그대로 적용될 수 있어야 한다.  
> DP 에서와의 다른 점은, 그리디 알고리즘은 부분 문제의 결과에 다음 문제가 영향을 받지 않는다는 점이다!  

### 구현 방식
* 각 요소들을 특정 기준으로 정렬한다.
* 정렬한 요소들을 훑으며 부분 문제들을 해결하면서 결과적으로 전체 문제를 해결한다.

## 참고
[자료구조 / 트리의 개념, 종류 그리고 순회](https://medium.com/quantum-ant/%ED%8A%B8%EB%A6%AC-tree-cec69cfddb14)  
[트리 순회 알고리즘 수도코드](https://designatedroom87.tistory.com/10)  
[알고리즘 / 그리디 알고리즘](https://hongjw1938.tistory.com/172)  
[그리디 알고리즘 예제](https://dev-gorany.tistory.com/5)  
