## 문법

### 입출력 받는 방법
- 코틀린 기준으로, 코틀린은 자바를 계승발전시킨 언어이므로 입출력을 받는 방법도 자바와 거의 비슷하다.
- 입력의 경우 Scanner 클래스를 import 하여 nextLine() 함수를 호출해 입력을 받거나, BufferedReader 클래스를 import 하여 readLine() 함수로 입력을 받는 방법이 있다.
- 출력의 경우 print 나 println을 사용한다. print 는 개행이 없고, println 은 개행을 적용하여 출력하는 함수다. ( 여담으로 코틀린은 자바의 System.out.print(), System.out.println() 과 같은 출력함수보다 더 간편하게 쓸 수 있다는 장점이 있다. )


### 사칙연산
- 코틀린의 경우 사칙연산은 자바와 완전히 동일하다. 산술연산자 +(더하기) , -(빼기) , *(곱하기) , /(나누기- 반환값은 몫) , %(나누기 - 반환값은 나머지) 으로 연산이 가능하다.


### if 문
- 대표적 조건문으로, 조건의 경우에 따라 반환되는 값이 달라져야 할 경우 사용한다.
- 용례는 자바와 똑같다.
```kotlin
  if (조건) {
     // 위 조건에만 해당하는반환값
  }
  else if (조건) {
     // 또 다른 조건에만 해당하는 반환값
  }
  else {
     // 그 외 나머지 반환값
  }
```

### for 문과 while 문
- 대표적 반복문들이다. 둘의 차이점이라면 for문은 조건이 거짓일 때까지 계단식으로 증가하거나 감소하면서 반환값을 내놓는 로직이고, while문은 조건이 거짓일 때까지 반환값을 내놓는 로직이다. 좀 더 구체적으로 for문의 경우는 조건에 한계를 정하게끔 설계되어 있어 유한성이 있는 반복에 가까운 반면, while문은 한계를 정해주지 않을 수도 있기 때문에 무한성이 있는 반복이라는 차이점이 있다. ( 물론 for문으로도 무한루프를 구현할 수는 있지만 조건이 무한히 참이게끔 만들어주어 무한루프를 돌리는건 for문의 사용의도와 맞지 않기 때문에 굳이 그렇게 사용하지 않아서 고려하지 않았다. )
- 용례는 다음과 같다.
```kotlin
  for (조건) { // 보통 i in 0..n 의 형태로 많이 사용한다. 0부터 n까지의 횟수만큼 반복하겠다는 의미이다.
     // 반환값
  }
  
  while (조건) { // 조건이 거짓이여야 이 while문을 빠져나가 반복시행을 멈출 수 있기 때문에 만약 조건이 영원히 거짓이 되지 않는다면 무한루프에 빠지게 된다. 그래서 무한성이 있다고 한 것.
     // 반환값
  }
```

### 1차원 배열
- 배열은 저장공간을 만들어주는 것과 같다. 배열의 쓰임새를 비유해보자면 그런거다. 만약 사과 10개를 현재 위치에서 멀리 떨어진 곳으로 옮겨야 한다고 가정해보자. 그리고 사과는 한손에 하나밖에 못 쥔다는 제약조건을 달아보자. 만약에 사과 10개를 옮기려면 두 손에 하나씩 들고 5번을 왔다갔다 해야 10개를 다 옮길 수 있지만, 만약 사과를 다 바구니에 담아서 들고 이동한다면 일은 한번에 끝난다. 바구니가 배열에 해당한다. 배열이란 그런 필요성에 의해 만들어졌다.
- 배열은 보통 빈 저장공간을 선언하는 것으로 시작한다. (물론 배열을 선언하면서 값도 동시에 넣어서 선언할 수도 있지만, 보통의 경우 빈 배열을 선언하면서 컴퓨터에게 '이건 사과를 담을 바구니야.' 라고 알려주는 것부터 시작한다. 그 다음 '바구니에 사과를 담아' 라는 명령을 내리는 식이다. ( 한번에 끝낼 수도 있는 작업을 굳이 이렇게 나눠서 처리하는 이유는, 유지보수시에 더 편리하기 때문. 뭐든 섞이면 나중에 수정시 골치아프다.)
- 코틀린의 경우 빈 배열을 선언하고 데이터를 삽입하는 용례는 이렇다.
```kotlin
 fun main() {

 var arr = Array<Int>(3, {0}) // 배열크기 : 3 , 3개의 배열을 값들을 모두 0으로 초기화
	var arr = IntArray(3) // 위의 Array<Int>(3, {0})을 이렇게 간단히 표현해 줄 수도 있음
    arr[1] = 1 // 1번 배열에 1을 넣겠다
    arr[2] = 2 // 2번 배열에 2를 넣겠다
}
```
- println(arr[1]) 이런식으로 배열의 인덱스 값으로 탐색하여 출력함수에 넣어주면 된다.

</br>
</br>

## 스택


### 개념

- 스택은 택배 상하차로 이해하면 쉽다.
- 트럭이 컴퓨터고, 택배가 데이터라면 기본적으로 트럭에서 택배를 넣고 빼는 행위를 컴퓨터에서 데이터를 삽입하거나 삭제하는 것에 비유할 수 있다.
- 트럭의 적재공간의 입출구는 하나기 때문에, 가장 먼저 넣은 택배를 가장 나중에 꺼내게 되는 것이 자연스러운데 여기서 스택의 선입후출(혹은 후입선출) 속성을 이해할 수 있다.
- 다음은 스택 자료구조를 그림으로 표현한 것이다.

![img](https://media.vlpt.us/images/sbinha/post/17a3cf61-fb95-4970-b66c-92a71b99846b/Screenshot%202020-04-20%2019.07.55.png)

- push(삽입) , pop(삭제) , peek(가장 최상단의 데이터를 읽기) => 메서드 이름은 언어마다 다르므로 삽입,삭제,읽기 같은 처리를 하는구나 정도로 이해하면 된다.
- 스택이라는 이름의 물리적 무언가가 있는게 아니라, 컴퓨터 자료구조에서 데이터를 처리하는 메서드나 명령들의 작동원리를 개념화한 것이다.

### 시간복잡도
- 선입후출, 후입선출의 특징때문에 삭제나 삽입시 항상 맨 위의 데이터를 대상으로 하게 된다. ( 위에 그림을 보고 이해하면 더 쉽다. )
- 그래서 스택에서 삽입과 삭제의 시간복잡도는 늘 O(1) 이다. O(1)에서 O는 시간복잡도를 빅오 표기법으로 표현한건데 그건 알아서 구글링 해보길 바라고, 괄호 안의 1은 연산 횟수를 뜻하는 것이다.
- 컴퓨터한테 '삽입해' 또는 '삭제해' 라는 명령을 내렸을 때 어차피 대상은 항상 맨 위의 데이터이므로 연산은 1번으로 끝난다는 뜻이다. 그래서 O(1) 이다.
- 만약 특정 데이터를 찾아서 읽어야 한다면, O(n) 의 시간복잡도가 걸리게 된다. peek 함수는 항상 맨 위의 데이터밖에 못 읽어오는 바보함수기 때문에, 내가 맨 위에서 3번째 데이터를 읽어오고 싶다면 위의 데이터 2개를 삭제하고 읽어와야 한다.
- 그래서 1번째 데이터 삭제 - 2번째 데이터 삭제 - 3번째 데이터(맨 위로 올라옴) 읽기 와 같은 로직을 통해 '3번째 데이터를 읽어와' 라는 연산이 완료되므로, 이 경우 O(3)이 되는 것이다. 이런식으로 데이터를 읽어올 경우 연산횟수가 몇번이 될지는 랜덤이기 때문에 O(n) 이라는 시간복잡도로 표기를 하게 되는 것이다.


### 로직 
( 위의 pop, push 함수는 C 에서 사용하는 함수다. 여기서는 pop, push 와 같은 스택함수들을 코틀린으로 구현하여 설명해보려고 한다. 어차피 원리는 똑같다. )

코틀린에서는 완전히 C의 스택을 구현할 수 없으므로, 스택을 발전시킨 MutableList로 로직을 이해해보고자 한다. ( 자바의 Stack 라이브러리를 사용할 수도 있지만 프로그램이 많이 무겁다. )


```kotlin
 fun main() {
    // stack
    var mutableList = mutableListOf<Int>()

    // push = add (삽입)
    mutableList.add(1)
    mutableList.add(2)
    mutableList.add(3)

    // pop = removeAt (삭제)
    mutableList.removeAt(mutableList.size-1)

    // isEmpty or isNotEmpty ( Boolean 타입으로 판단 )
    println(mutableList.isEmpty())
    println(mutableList.isNotEmpty())

    // stack 크기
    println(mutableList.size)
}
```


### 장점

- 구현이 쉽다. (구현객체로 배열이나 리스트를 만들고 객체.메서드 형태로만 사용하면 데이터의 삽입,추가,읽기 등이 가능하기 때문에)
- 원하는 데이터로 접근 속도가 빠르다. (예를 들어, 웹 브라우저에서 링크를 여러 번 클릭하여 웹 페이지 스택이 쌓여 있을 때, 간단하게 뒤로가기 나 앞으로가기 버튼만 눌러도 자신이 원하는 페이지로 금방 접근할 수 있다.)



### 단점

- 데이터를 탐색하는데 있어 비효율적이다. 데이터를 자주 꺼내 읽어와야 하는 경우나 자주 삽입해야 하는 경우 많이 불편하다는 뜻이다. (만약에 웹 페이지 스택이 100개 쌓여 있다고 한다면 첫번째 페이지로 가고 싶을 땐 뒤로가기를 99번이나 눌러야 한다. 개념에서 봤듯이 스택의 원리 때문에 원소를 하나하나 꺼내가면서 원하는 데이터에 도달해야 하기 때문이다. 최상단 스택의 데이터만 읽을 수 있기 때문.)



### 결론

- 스택만의 장단점이 있으므로, 스택에 적합한 자료관리일 경우에만 사용하는 것이 좋겠다.



### 참고
https://www.youtube.com/watch?v=WB_BoAgWLNU&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=14&ab_channel=%EB%8F%99%EB%B9%88%EB%82%98
https://velog.io/@choiiis/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9DStack%EA%B3%BC-%ED%81%90Queue
https://choheeis.github.io/newblog//articles/2020-10/kotlinStack



