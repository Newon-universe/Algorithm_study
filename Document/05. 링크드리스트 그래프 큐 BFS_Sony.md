
## LinkedList

### ◾ 개념 및 형태
연결 리스트(LinkedList)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식의 자료구조다. 데이터를 담고 있는 노드들이 연결되어 있고, 노드의 포인터가 이전 노드와 다음 노드와의 연결을 담당한다. Node는 LinkedList에 객체를 추가하거나 삭제하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 중간에 데이터를 추가나 삭제하더라도 전체의 인덱스가 한 칸씩 뒤로 밀리거나 당겨지는 일이 없기에 ArrayList에 비해서 데이터의 추가나 삭제가 용이하나, 인덱스가 없기에 특정 요소에 접근하기 위해서는 순차 탐색이 필요로 하여 탐색 속도가 떨어진다는 단점이 있다. 그러므로 탐색 또는 정렬을 자주 하는 경우엔 배열을 사용하고 데이터의 추가/삭제가 많은 경우 연결 리스트를 사용하는 것이 좋다.
![](https://blog.kakaocdn.net/dn/bqsySc/btqEk1stewE/tnty2kV69c7l45eyUO3Jh0/img.png)
ArrayList는 내부 배열에 객체를 저장해서 인덱스로 관리하는데 비해서 LinkedList는 위와 같이 인접 참조를 링크해서 체인처럼 관리한다.

### ◾ 언어별 선언 및 사용방법(CRUD)
> JAVA
```java
LinkedList list = new LinkedList();//타입 미설정 Object로 선언된다.
LinkedList<Student> members = new LinkedList<Student>();//타입설정 Student객체만 사용가능
LinkedList<Integer> num = new LinkedList<Integer>();//타입설정 int타입만 사용가능 
LinkedList<Integer> num2 = new LinkedList<>();//new에서 타입 파라미터 생략가능 
LinkedList<Integer> list2 = new LinkedList<Integer>(Arrays.asList(1,2));//생성시 값추가
```
### ◾ 시간복잡도
- n개의 요소에서 중간 지점에 1개의 데이터를 add/get할 때
add() : O(n)
get() : O(n)

- 순차적으로 n개의 데이터를 리스트 끝에 add 할 때
add() : O(n)
### ◾ 장점
삽입이 간단하다. 항목 생성 후 포인터 값만 변경해주면 된다.  
  
### ◾ 단점
**1. 항목 접근이 오래 걸린다.**

-> 첫 항목부터 순차적으로 접근하므로 최대 O(n)의 시간이 걸린다.

**2. 물리적으로 인접한 메모리에 위치해있지 않다.**

-> 배열의 항목은 물리적으로 인접해있어 접근 시간 단축과 캐싱에 유리하다고 한다. 하지만 연결리스트는 아니다.

**3. 참조 포인터를 위한 메모리 공간이 낭비된다.**

</br>

## 그래프

### ◾ 개념
**그래프**는  **객체들이 쌍으로 연관되어 집합을 이루는 구조**를 의미한다. 말이 어렵다면, 그래프 구조의 일종인 트리(Tree) 구조를 생각하면 된다.

트리(Tree) 구조 또한 노드(Node)들이 부모/자식 관계로 연결되어 있었다. 노드(Node)가 객체이며 그 관계를 연관성으로 하나의 전체 구조를 이루었다고 보면 된다. 트리(Tree) 처럼, 그래프 또한 내부적으로 부분 그래프(Sub Graphs)로 이루어진다.

### ◾ 구성요소
-   정점(Node, Vertex) - 객체, 위치의 개념
-   간선(Edge) - 정점 간의 관계, 연결선(Link, Branch)
-   인접 정점(Adjacent vertex) - 1개의 간선으로 직접 연결된 정점
-   정점 차수(Degree) - 하나의 정점에 인접해 있는 간선의 개수
-   진입 차수(In-Degree) - 방향성이 있는 그래프에서 외부에서 오는 간선의 수(내차수라고도 부른다)
-   진출 차수(Out-Degree) - 방향성이 있는 그래프에서 외부로 향하는 간선의 수(외차수라고도 부른다)
-   경로 길이(Path Length) - 정점에서 정점 간 경로 구성 시 사용된 간선의 수
-   단순 경로(Simple Path) - 구성된 경로 중에서 반복되는 정점이 없는 경우
-   사이클(Cycle) - 경로 중에서 시작 / 종료의 정점이 동일하여 내부적으로 순환이 발생하는 경우

### ◾ 구현방법 1 : 인접 리스트 이용
![](https://blog.kakaocdn.net/dn/78KDd/btqLf7Gcpcz/k7KokIz7EHdhS4m16U6rU0/img.png)
인접 리스트는 **정점(혹은 노드)와 정점 간의 연결을 리스트 형태로 나타내는 것**을 의미한다. 리스트 형태의 배열을 생성하고 각각의 위치(Index)에 리스트를 저장하여 정점 간의 연결성을 구현하는 방법이다.

- 시간복잡도
    리스트에 각 정점에 연결된 간선의 개수 만큼 저장되므로 `O(E)`

> JAVA
```java
public  class  graphLinkedList{  
	private ArrayList<ArrayList<Integer>> listGraph;  
	public  graphLinkedList(int size){ 
		listGraph =  new  ArrayList<ArrayList<Integer>>();  // 그래프 전체를 연결하는 첫번째 pointer 

		

for(int i=0; i<size+1; i++){ 
			listGraph.add(new  ArrayList<Integer>());
		}  
		// 각 arraylist를 추가하기
	}
}
```

### ◾ 구현방법 2 : 인접 행렬 이용
인접 행렬은 **N * N 형태의 행렬(2차원 배열)을 통해 연결성이 있는 경우에는 0이 아닌 다른 숫자를 저장**하여 연결성을 표현하는 방식이다.

- 시간복잡도
배열이 VxV형태가 되기 때문에 특정 정점의 0이 아닌 경우를 모두 찾아야 하기 때문에 `O(V)`

> JAVA
```java
public  class  graphArray{
	private  int[][] array;
	
	public  graphArray(int size){  // 행렬 그래프 생성
		array =  new  int[size+1][size+1];
	}
	
	public  int[][]  getArray(){
		return array;
	}

	public  boolean  isEmpty()  {
		return array ==  null;
	}

	public  void  addDirectedEdge(int x,  int y)  {
		array[x][y]  =  1;
	}

	public  void  addCompleteEdge(int x,  int y)  {
		array[x][y]  =  1;
		array[y][x]  =  1;
	}

	public  void  deleteDirectedEdge(int x,  int y)  {
		array[x][y]  =  0;
	}

	public  void  deleteCompleteEdge(int x,  int y)  {
		array[x][y]  =  0;
		array[y][x]  =  0;
	}
}
```


</br>

## 큐

### ◾ 개념
![](https://blog.kakaocdn.net/dn/4xNC4/btq5pEMF0sO/Hz54KOz8oU8QwR8uCqyIMK/img.png)
Queue의 사전적 의미는 무엇을 기다리는 사람, 차량 등의 줄 혹은 줄을 서서 기다리는 것을 의미하는데 이처럼 줄을 지어 순서대로 처리되는 것이 큐라는 자료구조입니다. 큐는 데이터를 일시적으로 쌓아두기 위한 자료구조로 스택과는 다르게 FIFO(First In First Out)의 형태를 가집니다. FIFO 형태는 뜻 그대로 먼저 들어온 데이터가 가장 먼저 나가는 구조를 말합니다.
**Enqueue :** 큐 맨 뒤에 데이터 추가  
**Dequeue :** 큐 맨 앞쪽의 데이터 삭제

### Queue의 특징
**1.**  먼저 들어간 자료가 먼저 나오는 구조 FIFO(First In FIrst Out) 구조  
**2.** 큐는 한 쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행함  
**3.**  다른 한 쪽 끝은 리어(rear)로 정하여 삽입 연산만 수행함

**4.**  그래프의 넓이 우선 탐색(BFS)에서 사용  
**5.** 컴퓨터 버퍼에서 주로 사용, 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기 시킴

### ◾ 언어별 선언 및 사용방법(CRUD)
> JAVA
```java
Queue queue = new LinkedList(); // 타입 설정x Object로 입력 

Queue<QueueDemo> demo = new LinkedList<QueueDemo>(); // 타입을 QueueDemo클래스로 설정 

Queue<Integer> i = new LinkedList<Integer>(); // Integer타입으로 선언 
Queue<Integer> i2 = new LinkedList<>(); // new부분 타입 생략 가능 
Queue<Integer> i3 = new LinkedList<Integer>(Arrays.asList(1, 2, 3)); // 선언과 동시에 초기값 세팅 

Queue<String> str = new LinkedList<String>(); // String타입 선언 
Queue<Character> ch = new LinkedList<Character>(); // Character타입 선언
```  
 
### ◾ 시간복잡도
**Insertion** : `O(1)`
**Deletion** : `O(1)`
**Search** : `O(N)`

### ◾ 장점
큐의 단점 극복을 위해 **가장 많이 사용하는 방식**으로, **연결 리스트를 사용**한 것으로써, 큐의 길이를 쉽게 늘릴 수 있어 **오버플로우가 발생하지 않는 것**이 특징이다.  
필요에 따라 **환형으로 만들 수도 있으며, 환형으로 만들지 않아도 삽입과 삭제가 제한되지 않아 편리**하다.

### ◾ 단점
배열로 큐를 구현한 것으로 **크기가 제한**되어 있고 빈 공간을 사용하려면 **모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 매우 비효율적인 단점**이 있다.
</br>

## BFS (너비우선탐색 : Breadth First Search)

### ◾ 개념
![](https://blog.kakaocdn.net/dn/Q02IX/btqNJv5vkjp/gXc4bR2U9NmKpFE6ckIjDK/img.png)
"꼼꼼하게 좌우를 살피며 다니자"와 같이 시작 정점으로부터 가까운 정점을 먼저 방문하고

멀리 떨어져 있는 정점을 나중에 방문하는 알고리즘이다.

시작 정점을 지나고 나면 깊이가 1인 모든 정점을 방문하고, 그다음에는 깊이가 2인 모든 정점을 방문한다.

이런 식으로 한 단계씩 깊이를 더해가며 해당 깊이에 있는 모든 정점들을 방문해 나가다가 나중에는 더 이상 방문할 곳이 없을 때 탐색을 종료한다.

**사용하는 경우: 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.**

### ◾ 시간복잡도
정점의 수가 n이고, 간선의 수가 e인 그래프의 경우

-   그래프가  인접 리스트로  표현된 경우 O(n+e)
-   인접 행렬로  표현된 경우 O(n^2)이다.
### ◾ BFS와 DFS의 비교
dfs는 "깊게" bfs는 "넓게" 탐색한다.
![img](https://t1.daumcdn.net/cfile/tistory/997C3C3E5BD01AF41D)

### ◾ 코드
> JAVA - 인접 리스트로 구현
```java
import java.util.*; 
public  class BFS_List { 
	public static void main(String[] args) { 
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt(); // 정점의 개수 
		int m = sc.nextInt(); // 간선의 개수 
		int v = sc.nextInt(); // 탐색을 시작할 정점의 번호 
		
		boolean visited[] = new  boolean[n + 1]; // 방문 여부를 검사할 배열 
		LinkedList<Integer>[] adjList = new LinkedList[n + 1]; 
		for (int i = 0; i <= n; i++) { 
			adjList[i] = new LinkedList<Integer>(); 
		} 

		// 두 정점 사이에 여러 개의 간선이 있을 수 있다.
		// 입력으로 주어지는 간선은 양방향이다.
		for (int i = 0; i < m; i++) { 
			int v1 = sc.nextInt(); 
			int v2 = sc.nextInt(); 
			adjList[v1].add(v2); 
			adjList[v2].add(v1); 
		} 

		for (int i = 1; i <= n; i++) { 
			Collections.sort(adjList[i]); // 방문 순서를 위해 오름차순 정렬 
		} 

		System.out.println("BFS - 인접리스트"); 
		bfs_list(v, adjList, visited); 
	} 

	// BFS - 인접리스트 
	public static void bfs_list(int v, LinkedList<Integer>[] adjList, boolean[] visited) {
		Queue<Integer> queue = new LinkedList<Integer>();
		visited[v] = true; 
		queue.add(v); 

		while(queue.size() != 0) { 
			v = queue.poll(); 
			System.out.print(v + " "); 
			Iterator<Integer> iter = adjList[v].listIterator();
			while(iter.hasNext()) { 
				int w = iter.next(); 
				if(!visited[w]) { 
					visited[w] = true; 
					queue.add(w); 
				} 
			} 
		} 
	} 
}
```

</br>


## 참고

[코딩팩토리 LinkedList 사용법](https://coding-factory.tistory.com/552)
[# 자바 [JAVA] - 배열을 이용한 Queue (큐) 구현하기](https://st-lab.tistory.com/183)