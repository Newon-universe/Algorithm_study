## 이분 탐색 / 이진 탐색 (Binary Search)

### ① 개념
선형 자료 구조(리스트, 어레이, 스택, 큐 등)에서의 대표적인 탐색 방법으로 선형 탐색(linear search), 이분 탐색(binary search), 해싱이 있다.  
그 중에서도 `이분 탐색`은 `최악의 경우에도 선형 탐색보다 시간복잡도가 더 작아서` 자주 사용되는 탐색 방법이다.  

### ② 구현과정 및 구현조건
- 이진 탐색은 배열 내부의 `데이터가 정렬`되어 있어야만 사용할 수 있는 알고리즘이다.
- 원소에 `Random Access`가 가능해야 한다.
- `변수 3개(start, end, mid)를 사용`하여 탐색한다.  
  찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것이 이진 탐색의 과정이다.
  
![이분 탐색](https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif)  
  
  
### ③ 코드(반복문)
코드는 target 을 찾으면 target 을 리턴, 해당 값이 존재하지 않으면 -1 을 리턴한다.  

> Kotlin
```kotlin
fun binarySearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.lastIndex
    var mid = 0;

    while (low <= high) {
        mid = (low + high) / 2

        when {
            arr[mid] == target -> return arr[mid]
            arr[mid] > target -> high = mid - 1
            else -> low = mid + 1
        }
    }
    return -1
}
```

### ④ 코드(재귀)
> Kotlin
```kotlin

fun binarySearch(arr: IntArray, target:Int, left: Int, right: Int): Int {
    
    if (left > right)
        return -1
    
    val mid = (left + right) / 2
    if (target == arr[mid])
         return arr[mid]
    else if (target < arr[mid])
         return binarySearch(arr, target, left, mid - 1)
    else if (target > arr[mid])
         return binarySearch(arr, target, mid + 1, right)
}

```

### ⑤ 시간복잡도  
▷ 시간 복잡도는 `O(log N)` 이다.  
  
ﾠﾠ이분 탐색을 반복할 수록, 탐색할 자료의 개수가 절반으로 줄어든다.  
ﾠﾠ따라서 N개의 자료가 있을 때, 총 K번 자료를 검색한다면, 남은 자료의 개수는 `N ⋅ (1 / 2)^K` 이다.  
ﾠﾠ최악의 경우, 탐색 종료 시점에 남는 자료의 개수가 1이 되어야 하므로, `K = log(N / 2)` 이 된다.  

<br/>

### ⑥ 장단점  
▷ 장점  
  검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다는 장점이 있다.  
  
▷ 단점  
  검색 원리상 정렬된 리스트에만 사용할 수 있다.
  
<br/>

## 정렬

### ① 정렬의 종류와 개념
▷ 선택정렬
`선택정렬(Selection Sort)`은 해당 순서에 원소를 넣을 `위치는 이미 정해`져 있고, 그 위치에 `어떤 원소를 넣을지 선택`하는 알고리즘이다. 
 - 선택정렬은 제자리 정렬(in-place sorting) 알고리즘의 하나
 
> 제자리 정렬이란, 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법이며  
  해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘
  
  
▷ 삽입정렬
`삽입 정렬(Insertation Sort)` 란 앞에서부터 해당 원소가 위치 할 곳을 탐색하고 해당 위치에 삽입하는 것이다.  
추상화하자면 손안의 카드를 왼쪽에서 2번째 카드부터 `이전의 카드들을 비교해가며 밀어넣기` 하는 형태이다.
첫번째 카드는 손으로 직접 카드 주 가장 작은 숫자를 뽑아 넣어 놓는다.

유사한 개념인 선택정렬(Selection Sort)와 삽입정렬(Insertion Sort)이 종종 헷갈릴 수 있는데, 
선택정렬은 배열에서 해당 자리를 이미 선택하고 그 자리에 오는 값을 찾는 것이며,
삽입정렬은 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입하는 것 이다.
  
▷ 버블정렬
`버블 정렬(Bubble Sort)` 이란 인접한 두 원소를 비교해서 크기의 순서를 맞추는 알고리즘이다.

### ② 구현과정 및 구현조건
![선택정렬](https://blog.kakaocdn.net/dn/qjbEC/btqNiW4IUsW/6XCnYWRkk437W3kQYBDlP1/img.gif)  
![삽입정렬](https://blog.kakaocdn.net/dn/bxvpd6/btqOuH69gZU/s5NmD45Lo0HaI80sK9QXt1/img.gif)  
- 선택정렬과 삽입정렬은 가자 처음의 위치를 해당 배열의 최솟값으로 직접 설정해야한다.  
  
![버블정렬](https://t1.daumcdn.net/cfile/tistory/2518323758FDB83613)  
- 버블정렬은 특별한 조건 없이 수행할 수 있다.  
**그림 첨부해서 설명해주실 분들은 여기에 넣어주세요**


### ③ 코드(반복문)

> Kotlin
```kotlin
// 선택정렬
fun selectionSort() {
    for (i in 0 until lst.count() - 1) {
        var minVal = 0xffffff
        var minIdx = -1
        for (j in i until lst.count()) {
            if (minVal > lst[j]) {
                minVal = lst[j]
                minIdx = j
            }
        }
        lst[minIdx] = lst[i]
        lst[i] = minVal
    }
    print(lst)
}

// 삽입정렬
fun insertionSort() {
    val lst = mutableListOf(1, 34, 5, 6, 78, 23, 56, 31, 64)
    for (i in 1 until lst.count()) {
        val temp = lst[i]
        for (j in i - 1 downTo 0) {
            if (lst[j] < lst[i]) {
                lst[j + 1] = temp
                break
            } else {
                lst[j + 1] = lst[j]
            }
        }
    }
    println(lst)
}


// 버블정렬
fun bubbleSort(){
  var arr = arrayOf(5,3,4,1,2)

  for(i in 0..arr.lastIndex){
      for(j in 1..arr.lastIndex - 1){
          if(arr[i] > arr[j]){
              arr[i] = arr[j].also { arr[j] = arr[i] }
          }
      }
  }
}

```


### ⑤ 각 정렬방법의 시간복잡도  
※ 53412 를 오름차순으로 정렬하는 경우
▷ 선택정렬

▷ 삽입정렬

▷ 버블정렬

<br/>

### ⑦ 참고
[\[알고리즘\] 이분탐색](https://sirzzang.github.io/programming/Programming-Binary-Search/)  
[아인스트라세의 SW 블로그](https://eine.tistory.com/entry/이진-탐색-이분-탐색binary-search-구현시-고려할-것들 )  
[\[ 알고리즘 / Kotlin \] 이진 탐색(Binary Search) 알고리즘](https://gyubgyub.tistory.com/56)  
[게으름뱅이의 앞구르기](https://walk-through-me.tistory.com/35)  
[튜나 개발일기](https://devuna.tistory.com/28)  
[자바 \[JAVA\] - 선택 정렬 (Selection Sort)](https://st-lab.tistory.com/168)  
