## 이분 탐색 / 이진 탐색 (Binary Search)

### ① 개념
 탐색 기법중에 하나로 원하는 탐색범위를 두 부분으로 분할해서 찾는 방식.

### ② 구현과정 및 구현조건

![221D4A3F5705041A1F](https://user-images.githubusercontent.com/42407740/141604941-7f568872-487d-414e-b444-9502dce11e61.gif)

구현과정

1. 배열을 정렬한다.

2. 정렬된 배열에서 왼쪽 끝 인덱스 left와 오른쪽 끝 인덱스 right을 이용해 중간 인덱스 mid 값을 찾는다.

3. mid 인덱스와 배열에서 찾고자 하는 값 target을 비교한다.

4. target이 나올 때까지 탐색 과정을 반복한다.

5. mid 값보다 target이 크다면 left를 mid+1로 이동시켜, 오른쪽 구간에서 탐색한다.

6. mid 값보다 target이 작다면 right을 mid-1로 이동시켜, 왼쪽 구간에서 탐색한다.

7. target이 없다면, None을 반환한다.

구현조건

1. 원소가 정렬이 되어 있을 것(오름차순이든 내림차순이든)

2. 원소의 Random Access가 가능해야 한다.

3. 자료의 집합은 인덱스를 바꿀 때 상수 시간으로 처리되어야 합니다. Big O: (1)

```
function 이진탐색(데이터, 찾는 값)

데이터가 혹시 비어 있는가?
(네) return 찾는 값 없음.

데이터의 가운데 지점을 찾는다.
찾은 지점의 값을 뽑는다.
뽑은 값이 찾는 값인가?

(네) return 뽑은 값.
(아니요)
  뽑은 값과 찾는 값을 비교한다.
  (뽑은 값이 찾는 값보다 큰 값인가?)
    return 이진탐색(데이터 앞쪽 절반, 찾는 값)
  (작은 값인가?)
    return 이진탐색(데이터 뒤쪽 절반, 찾는 값)
```

### ③ 코드(반복문)
> Java
```java

```
> Kotlin
```kotlin
fun binarySearch(arr: IntArray, target: Int): Int {
    var low = 0
    var high = arr.lastIndex
    var mid = 0;

    while (low <= high) {
        mid = (low + high) / 2

        when {
            arr[mid] == target -> return mid
            arr[mid] > target -> high = mid - 1
            else -> low = mid + 1
        }
    }
    return -1
}
```
> Python
```python
```

### ④ 코드(재귀)
> Java
```java

```
> Kotlin
```kotlin
fun binarySearch(arr: IntArray, target: Int, low: Int, high: Int): Int {
    if(low > high) {
      return -1
    }
    
    var mid = (low + high) / 2
  
    if (target == arr[mid]) {
        return mid
    }
    else if (arr[mid] > value) {
        return binarySearch(arr, low, mid - 1, target)
    }
    else 
        return binarySearch(arr, mid+1, high, target)
}
```
> Python
```python
```
### ⑤ 시간복잡도  
▷ 이분 탐색을 반복할 수록, 탐색할 자료의 개수가 절반으로 줄어든다. 따라서 N개의 자료가 있을 때, 총 K번 자료를 검색한다면, 남은 자료의 개수는 N⋅12K이다. 

최악의 경우, 탐색 종료 시점에 남는 자료의 개수가 1이 되어야 하므로, K=logN2이 된다. 따라서, 시간복잡도는 O(logN)이다.

<br/>

### ⑥ 장단점  
▷ 
장점 : 선형 탐색과 비교하여 탐색 시간이 빠르다. (선형 탐색의 경우 시간 복잡도는 T(n) = θ(n)이다. )
단점 : 정렬된 리스트에서만 사용될 수 있다.
<br/>

## 정렬

### ① 정렬의 종류와 개념
▷ 선택정렬
▷ 삽입정렬
▷ 버블정렬

### ② 구현과정 및 구현조건

**그림 첨부해서 설명해주실 분들은 여기에 넣어주세요**

```
sudo 코드로 설명하실분은 여기에 넣어주세요!
// 선택정렬

// 삽입정렬

// 버블정렬
```

### ③ 코드(반복문)
> Java
```java
// 선택정렬

// 삽입정렬

// 버블정렬
```
> Kotlin
```kotlin
// 선택정렬

// 삽입정렬

// 버블정렬
```
> Python
```python
// 선택정렬

// 삽입정렬

// 버블정렬
```

### ⑤ 각 정렬방법의 시간복잡도  
※ 53412 를 오름차순으로 정렬하는 경우
▷ 선택정렬
▷ 삽입정렬
▷ 버블정렬
<br/>

### ⑦ 참고
[이진탐색](https://namu.wiki/w/%EC%9D%B4%EC%A7%84%20%ED%83%90%EC%83%89)
[이진-탐색-이분-탐색binary-search-구현시-고려할-것들](https://eine.tistory.com/entry/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%EC%9D%B4%EB%B6%84-%ED%83%90%EC%83%89binary-search-%EA%B5%AC%ED%98%84%EC%8B%9C-%EA%B3%A0%EB%A0%A4%ED%95%A0-%EA%B2%83%EB%93%A4)
