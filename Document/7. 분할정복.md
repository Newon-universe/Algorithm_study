### **1. 개념**

문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘

<img width="867" alt="스크린샷 2021-11-04 오후 11 21 33" src="https://user-images.githubusercontent.com/87492707/140330773-32b9402d-e338-4499-b0f9-2cf0f59a9182.png">
</br>

### **2. 특징**

- 하위 문제를 재귀적으로 해결하기 때문에 하위 문제 각각은 원래 문제보다 범위가 작아야 하며 하위 문제는 각 문제마다 탈출 조건이 존재해야 한다
- 분할 정복 알고리즘은 최소 두 개의 하위 문제를 생성하므로 여러번 재귀 호출한다
    (꼭 재귀호출로 해야해야만 하는 것은 아니다)
    
- 분할된 작은 문제는 원래 문제와 성격이 동일하다 -> 입력 크기만 작아짐
- 분할된 문제는 서로 독립적이다(중복 제거 X) -> 순환적 분할 및 결과 결합 가능
- 최댓값 구하기, 쉬트라센 행렬곱셈, 퀵정렬, 이분검색, 합병정렬 등에 분할정복법이 쓰인다
</br>

### **3. 장단점**

- Top-down 재귀방식으로 구현하기 때문에 코드가 직관적이라는 장점
- 같은 작업을 더 빠르게 처리할 수 있다는 장점
- 재귀호출로 인한 단점도 존재
- 함수 호출로 인한 오버헤드, 스택오버플로우 발생 가능 (이 경우 메모이제이션으로 해결)

</br>

### **4. 분할정복 알고리즘의 처리과정(문제해결과정-기본로직)**
 ① 분할: 원래 문제를 분할하여 비슷한 유형의 더 작은 하위 문제들로 나눈다 </br>
 ② 정복: 하위 문제 각각을 재귀적으로 해결한다. 하위 문제의 규모가 충분히 작으면 문제를 탈출 조건으로 놓고 해결한다 </br>
 ③ 합치기: 하위 문제들의 답을 합쳐서 원래 문제를 해결한다

</br>

### **5. 시간복잡도**

O(NlogN)

</br>

### **6. 분할정복 방법이 적용된 병합 정렬(Merge sort), 퀵 정렬(Quick sort)에서의 분할 과정**

**분할 정복 패러다임 기반으로 만들어진 정렬 알고리즘2**

**1) 병합정렬**

: 주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두개로 만든 뒤 이들을 재귀호출을 이용해 각각 정렬(계속 절반으로 분할) 하는 방법

① 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. </br> 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
② 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
③ 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

</br>

**2) 퀵정렬**

: 특정 원소 피봇(pivot)을 기준으로 주어진 배열을 두 부분 배열로 분할하고 각 부분 배열에 대해 퀵 정렬을 순환적으로 적용하는 방식


  ① Divide : 피봇 하나를 선택하여 피봇을 기준으로 2개의 부분 배열로 분할한다.

  ② Conquer : 피봇을 기준으로 피봇보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서 부터 피봇보다 큰 값을 찾고 오른쪽에서 부터는 피봇보다 작은 값을 찾아서 두 원소를 교환한다. 분할된 부분 배열의 크기가 0이나 1일 될때까지 반복한다.

  ③ Combine : conquer 과정에서 값의 위치가 바뀌므로 따로 결합은 하지 않는다.

</br>

### **7. 동적 계획법(Dynamic Programming)과 분할정복법(Divide and Conquer) 비교**

- 공통점
    - 문제를 작게 쪼개서 가장 작은 단위로 분할
- 차이점
    - 분할정복법은 Top-down 방식이며, DP는 Bottom-up 방식이다
    - DP는 부분 문제가 중복되고 상위 문제 해결 시 재활용되지만, 분할정복법에서 부분문제는 서로 중복되지 않음
    - DP에서는 부분문제의 해답을 저장해 재활용하는 최적화 기법으로 메모이제이션을 사용하지만, 분할정복법에서는 사용하지 않음
    


