## 링크드리스트

### ◾ 개념 및 형태
링크드 리스트, 연결 리스트란 하나의 노드에 해당 벨류값과 다음 노드에 대한 주소값이 있어  
계속해서 이어지는 형태의 자료구조를 의미한다.  
  
<img src = "https://media.vlpt.us/images/sangh00n/post/bfa73611-96a7-450a-9974-4b40fb70c2fd/linkedLIst.png">

처음 부분을 front, head 등으로 부르고 마지막 부분을 rear, tail 등으로 부르나 의미는 똑같다.  
보통 그래프나 관계성을 지니는 데이터를 가질 때 이용한다.  
### ◾ 언어별 선언 및 사용방법(CRUD)
코틀린은 자체 내자 함수로 링크드 리스트를 지원한다.
```Kotlin
var SampleList = LinkedList()      // 링크드 리스트 생성

SampleList.addNodeAtLast(N)                       // 링크드리스트의 마지막에 데이터를 추가한다. 따라서 이전의 마지막 데이터가 추가하는 데이터와 연결된다.
SampleList.addNodeAtFront(N)                      // 링크드리스트의 처음에 데이터를 추가한다. 추가한 데이터가 이전의 처음 데이터와 연결된다.
SampleList.addNodeAtPosition(5, N)                // 해당 위치에 데이터를 추가한다. position - 1에 위치한 데이터가 추가하는 데이터와 연결된다.

SampleList.removeAtFront()                        // 링크드리스트의 처음 데이터를 삭제한다. 연결관계는 변하지 않는다.
SampleList.removeAtLast()                        // 링크드리스트의 마지막 데이터를 삭제한다. 연결관계는 마지막 - 1의 데이터의 연결 데이터가 NULL 이 된다.
SampleList.removeAtPosition(5)                   // 해당 위치의 데이터를 삭제한다. 연결관계는 위치 - 1 과 위치 + 1 의 데이터가 연결된다.

SampleList.printAllElement()                     // 링크드리스트의 모든 벨류들을 출력한다.
```
### ◾ 시간복잡도
- 검색 : `O(N)`  
  
- 처음에 추가 혹은 삭제 : `O(1)`  
  
- 마지막에 추가 혹은 삭제 : `O(N)`
### ◾ 장점
- 자료의 삽입과 삭제가 용이하다.
- 리스트내에서 자료의 이동이 불필요하다.
- 사용 후 기억장소의 재사용이 가능하다.
- 연속적인 기억 장소의 할당이 필요하지 않다.

### ◾ 단점
- 포인터의 사용으로 저장 공간의 낭비가 생길 수 있다.
- 알고리즘이 복잡하다.
- 특정 자료의 탐색 시간이 많이 소요된다.
  
  
_LinkedList 와 ArrayList 의 시간복잡도 차이_  
<img width="553" alt="스크린샷 2021-10-23 오후 5 50 17" src="https://user-images.githubusercontent.com/80164141/138549850-0d24ffe5-58da-46c3-b0e6-cda3aabbfdf5.png">

</br>

## 그래프

### ◾ 개념
노드 `Node` 와 그 노드들을 연결하는 간선 `Edge` 을 하나로 모아놓은 자료구조를 의미한다.  

#### 인접과 차수
간선으로 이어진 노드들을 `인접한 노드`라고 정의한다.  
즉, 노드가 `1, 2, 3, 4` 있고 간선이 `1->3` 이 존재한다고 하면  
`1과 3은 인접한 상태이다.`, `1과 2, 4`는 인접하지 않은 상태이다.  

차수는 하나의 노드에 주어지는 간선의 수르 의미한다.  
즉, 노드가 `1, 2, 3, 4` 있으며 간선이 `1->2`, `1->3`으로 존재한다고 하면  
`노드 1의 차수는 2`이다.  

#### 방향과 무방향
그래프에 방향이 존재한다면, 간선은 일방통행이다.  
즉 1->3 이 3->1을 의미하지 않게 된다.
  
그래프에 방향이 존재하지 않다면 간선은 양방통행이다.  
즉 1->3 은 3->1의 간선도 포함한다.  
  
### ◾ 구현방법 1 : 인접 리스트 이용
인접 리스트는 링크드리스트를 배열로 담아서 저장한 자료구조를 의미한다.  


### ◾ 구현방법 2 : 인접 행렬 이용
인접 행렬은 N x N 의 배열을 사용하여, `N번 노드` 와 `M번 노드`가 이어진다면  
`배열\[N\]\[M\] = 1, 배열\[M\]\[N\] = 1` 을 하는 방식으로 만들 수 있다.  

</br>

## 큐

### ◾ 개념
자료구조 중 하나  
  
하나의 배열이 있을 때 언제나 가장 처음 들어간 것이 먼저 나오고, 나중에 넣은 것이 나중에 나오는  
FIFO(First In First Out)을 만족하는 자료구조로, 슈퍼마켓의 우유를 배치하는 것과 같다.  
  
코틀린에서는 보통 Queue 를 생성하고, 해당 큐를 링크드리스트로 연결해 사용하는 경우가 많다.    
### ◾ 언어별 선언 및 사용방법(CRUD)
코틀린은 자체 내장 함수로 큐를 지원하고 있다.

```Kotlin
lateinit var SampleQueue : Queue<Int>         // Queue 생성, Queue 에 들어갈 자료형을 <...> 안에서 지정할 수 있다.
SampleQueue = LinkedList()                    // 처음 생성한 큐는 아무것는 상태이다, 따라서 Queue 에서 사용할 배열 혹은 자료구조를 선언한다.

SampleQueue.add(N)                            // .add 는 Queue 에 하나의 자료를 넣는 명령어로, 가장 마지막에 넣은 벨류값 뒤에 위치하게 된다.
                                              // 성공 시 true 를, 실패 시 false 를 리턴한다.

SampleQueue.poll(N)                           // .poll 은 Queue 에 하나의 자료를 빼는 명령어로, 가장 처음 넣었던 벨류를 출력한다.
                                              // 큐가 비어있는 경우 NULL 을 리턴한다.

SampleQueue.peak                              // 현재 큐의 front, 즉 다음에 poll 했을 때 나올 Queue 의 벨류값을 출력한다.
```

### ◾ 시간복잡도
- 검색 : `O(N)`  
  
- 처음에 추가 혹은 삭제 : `O(1)`  
  
- 마지막에 추가 혹은 삭제 : `O(N)`

### ◾ 장점
- 자료의 삽입과 삭제가 용이하다.
- 리스트내에서 자료의 이동이 불필요하다.
- 사용 후 기억장소의 재사용이 가능하다.
- 연속적인 기억 장소의 할당이 필요하지 않다.
  
> 링크드리스트와 동일하다.  

### ◾ 단점
- 포인터의 사용으로 저장 공간의 낭비가 생길 수 있다.
- 알고리즘이 복잡하다.
- 특정 자료의 탐색 시간이 많이 소요된다.
  
> 링크드리스트와 동일하다

</br>
## BFS (너비우선탐색 : Breadth First Search)

### ◾ 개념
노드로부터 인접한 대상을 먼저 탐색하는 방법을 일컫는다.  
  
BFS는 큐를 활용하여 인접한 노드들을 큐에 넣고`(enqueue)`,  
다시 큐로부터 새로운 노드를 받아서`(dequeue)` 해당 노드에 인접한 노드들을 큐에 넣는`(enqueue)` 방식이 일반적이다.  
  
따라서 BFS는 보통 3개의 단계로 구분된다.  
```Kotlin
var SampleQueue : Queue<Int>;   // Queue 생성
SampleQueue.add(1);             // Queue 에 초기값 0 add

var nextDirection:IntArray(2) = {-1, 1, 0, 0);   // 다음으로 움직일 곳


// Dequeue 단계
while(SampleQueue.peak){
   var dequeue;
   dequeue = SampleQueue.poll
   
   
// 다음에 들어갈 수 있는 노드 탐색   
   for(i in 0..1){
        var next = dequeue + nextDirection[i];       
        
        if(next < 0 || next >= N)                //해당 노드를 Queue 에 넣어도 되는 값인지 확인
           continue;
        if(...)                                  // 즉, 방문처리와 같다. (넣었던 노드를 다시 넣으며 안됨, 노드가 아닌 값을 넣으면 안됨, 특정조건 등)
           continue;
           
           
// Enqueue 단계        
        SampleQueue.add(next);                    // 노드를 Enqueue 하고, dequeue 한 값에서 인접한 노드들에 대한 탐색이 끝나면
                                                  // 큐에서 꺼내 새로운 노드로 위 과정을 반복한다.
   }
}

```
### ◾ 시간복잡도

### ◾ BFS와 DFS의 비교
BFS 가 인접한 노드를 기준으로 탐색을 한다면, DFS 는 링크드리스트 기준으로 다음의 리스트를 계속해서 탐색한다는 특징이 있다.  
### ◾ 코드
</br>


## 참고
[자료구조 : Linked List 대 Array List](https://www.nextree.co.kr/p6506/)  
[\[자료구조\] 그래프\(Graph\)란](https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html)
