## 수학과 다이나믹 프로그래밍

### 소수
#### ◾ 개념
1보다 큰 자연수 중에서 약수가 1 또는 자기 자신인 수를 말한다. 1보다 크기 때문에 1은 제외다. 여담이지만 소수 중 짝수는 2뿐이다.

#### ◾ 기본 로직

```Kotlin
 fun main() {
    
    var num: Int = 3 // 소수인지 아닌지 알아보고 싶은 숫자 입력
    var flag: Boolean = true // 소수판별 플래그 (false면 합성수, true면 소수)
    
    while(true) {
        
        if (num == 2) {
            flag = true
        }
        
        for (i in num - 1 downTo 2) { // num으로 들어온 숫자를 제외(자기 자신 제외)하고 1씩 감소해서 2까지 모든 수로
            if (num % i == 0) { // num을 2 ~ num -1 까지의 수들로 각각 다 나눠봤을 때 '하나라도' 나눠 떨어지는 수가 걸린다?
                flag = false // 그럼 num 얘는 소수가 아님. (자기 자신 또는 1 말고는 그 어떤 수로도 나눠 떨어지면 안되기 때문)
                break
            }
        }
        
        if (flag == false) {
            println("소수가 아니다.")
        } else {
            println("소수다.")
        }
    }
    
}
```

#### ◾ 에라토스테네스의 체

1. 1보다 큰 자연수이므로 1은 제외
2. 2부터 어느 숫자까지 소수의 개수를 체크할건지, 숫자를 정한다.
3. 2는 소수조건을 충족, 3,5,7 도 충족
4. 2를 제외한 짝수는 모두 지운다. (2보다 큰 짝수는 다 2로 나눠지므로)
5. 홀수 중에서 3,5,7의 배수들도 모두 지운다. (배수를 지워주는 이유는 어떤 수든(소수라 할지라도) 자기 자신을 더하는 순간 2로 나눠지기 때문)
6. 2에서 정한 숫자까지 소수만 남게 된다.

```Kotlin
 fun main() {
    val prime : Array<Boolean> = Array(1001) {true} // 1001 개의 배열을 선언하고 모든 배열을 boolean 값을 true로 초기화한다. ( 1001개를 하는 이유는 1~1000까지 소수인 수(true), 소수가 아닌 수(false)로 가려내어 소수가 몇개 있는지 가려내기 위해서인데, 배열 인덱스는 0부터 시작하므로 0~1000까지 1001개의 배열을 선언해줬다.)
    var count = 0 // 소수의 개수가 들어갈 변수
    var num = 0 // 1 ~ num 까지 소수가 몇개인지 체크하기 위한 입력 변수 (사실 하드코딩으로 입력해주는거지만)
    
    prime[0] = false
    prime[1] = false // 0과 1은 소수가 아니니까 false로 초기화
    for (i in 2..1000) { // 2 ~ 1000 까지 돌면서 체크
        if (prime[i]) { // i가 2일 때로 가정해보자
            for (j in 2 * i..1000 step i) { // 4 ~ 1000 까지 2씩 더해서 2의 배수 제거, 6 ~ 1000까지 3씩 더해서 3의 배수 싹 다 제거, 8 ~ 1000까지 4씩 더해서 4의 배수 싹 다 제거 ... 
               prime[j] = false // 2를 곱했기 때문에(2 * i) 2를 제외한 짝수는 다 걸러지고 (2보다 큰 짝수들은 다 2로 나눠지니까 소수에서 탈락), 어떤 홀수라도 자기 자신을 더하게 되면(step i) 무조건 2로 나눠지므로 다 탈락
            }
        }
    }
    // 소수의 배수들을 싹다 false 처리

    for (i in 0 until num){ // 그럼 0 ~ num 까지의 인덱스 배열 중
        if (prime[num] == true) { // true값을 가진 배열만 남게되는데 그 안에 들은 수들이 소수다.
          count++ // count 변수에서 집계
        }
    } // num의 개수만큼 반복문을 돌면서 그 안에 소수가 몇개인지 판별

    println(count) // 1 ~ num 까지 소수의 개수 출력

}
```

#### ◾ 시간 복잡도
> 기본 로직 = 대충 O(n2) 정도? n까지의 각 수를 그 n만큼의 시행으로 소수인지 아닌지를 체크하기 때문에 n의 제곱정도 복잡도에 근접한걸로 판단된다. 중복시행이 많기 때문에 효율적이지 않다.
> 에라토스테네스의 체 = O(Nlog(logN)) 그냥 존나 빠르다고 알면 된다.

</br>

### 다이나믹 프로그래밍
#### ◾ 개념
- "어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는" 방식의 알고리즘을 총칭한다. 
- 동적계획법 이라고도 한다.(다이나믹 프로그래밍을 억지 번역한 것 같은 냄새가 나는데 심지어 이 용어를 만든 사람도 개념과는 무관하게 그냥 지가 생각하기에 기똥차다, 다이나믹하네 해서 갖다 붙였다고 한다.) 
- 말이 어려운데, 1 + 1 = 2 처럼 2항 계산까진 할 수 있는데 1 + 1 + 1 처럼 3항 이상이 되면 계산을 못하겠다고 쳐보자. 그러면 1 + 1 = 2 로 구해진 해를 이용해 (1 + 1)를 2로 바꾸어 2 + 1 이라는 2항 계산으로 바꾸어 3 이라는 답을 도출하는 알고리즘이다. (예를 1 + 1로 들어서 그렇지 1 자리에 함수 하나만 들어가도 난리난다.)

#### ◾ 조건  
**1. 첫번째 조건**  
> 작은 문제가 여러 번 재사용 되는 구조여야 한다.(위의 예시와 피보나치 수열을 떠올려 보자.) 이 점이 큰 문제를 한꺼번에 해결하기 어려워 단순히 문제를 쪼개어 조각조각 해결하는 분할정복과 다른 점이다. (분할정복은 우리가 어떤 운동을 배울 때 구분동작으로 나눠서 그 동작들을 연결시켜 체화하는 방식으로 비유해보면 이해가 쉽다.)

**2. 두번째 조건**  
> 큰 문제의 문제해결을 작은 문제들의 해결방법에서 유추할 수 있는 구조여야 한다. (규칙성을 찾을 수 있어야 한다는 말과 거의 동일하다.)

#### ◾ 메모이제이션(Memoization) 이란?
컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술.

#### ◾ 분할 정복 방식과의 차이점
분할정복 방식도 큰 문제를 나누긴 하지만, 나눠진 작은 문제들은 반복되거나 규칙성을 갖지는 않는다. (위의 첫번째 조건 예시 참고)

#### ◾ 기본 로직
**1. Top-down**  
> 재귀함수를 사용한다. 가장 큰 문제를 방문 후 작은 문제로 내려가며 답을 찾는 방식. 아래는 재귀함수를 통해 피보나치수열을 구현한 예제다.  재귀로 함수를 호출할 때마다 이전의 두 수의 합을 더하여 넘겨준다.
```Kotlin
 fun fibonacci(n: Int, first: Int, second: Int): Int {
    return if (n <= 0) {
        first
    } else {
        fibonacci(n-1, second, first + second)
    }
}

println("recursion - fibonacci(10) : ${fibonacci(10, 0, 1)}" )
```

**2. Bottom-up**  
> 반복문을 사용한다. 가장 작은 문제들부터 답을 구해 올라가며 전체 문제의 답을 찾는 방식. 아래는 반복문을 통해 피보나치수열을 구현한 예제다.
```Kotlin
 fun fibonacciLoop(n: Int): Int {
    var first = 1
    var second = 1
    return when (n) {
        1 -> first
        2 -> second
        else -> {
            var current = first + second
            for (num in 3..n) {
                current = first + second
                first = second
                second = current
            }
            current
        }
    }
}

println("Loop - fibonacci(10) : ${fibonacciLoop(10)}" )
```

</br>

### 참고
https://hanyeop.tistory.com/117
https://choheeis.github.io/newblog//articles/2020-04/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4
https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4
https://galid1.tistory.com/507
https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98
https://codechacha.com/ko/kotlin-examples-fibonacci/



