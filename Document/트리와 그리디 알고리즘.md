## 트리

### 개념
![트리 구조](https://media.vlpt.us/images/adam2/post/41b22e4e-c45b-4929-a6ae-c247a56ad91f/image.png)  
  
트리는 일반적으로 대상 정보의 각 항목들을 계층적으로 연관되도록 구조화시키고자 할 때 사용하는 비선형 자료구조이다.  
데이터 요소들의 단순한 나열이 아닌 부모-자식 관계의 계층적 구조로 표현이 된다.  

#### 조건  
트리는 1개 이상의 노드로 이루어진 자료 구조로 다음을 만족한다.  
- 트리는 하나의 `루트(root)` 노드가 있다.  
- `루트(root)` 노드는 0개 이상의 자식 노드들을 가지며, 자식 노드들 역시 반복적으로 정의된다.   

#### 특징
- 그래프의 한 종류로, `최소 연결 트리` 라고도 불린다.  
- 계층 모델이며, 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가진다.  
- `사이클(시작 노드와 마지막 노드가 같음)` 이 존재하지 않는다.  
- 모든 노드는 연결되어 있다.
- 노드가 N개인 트리는 언제나 N - 1 개의 간선만 가진다.  
- 두개의 노드 사이에는 반드시 1개의 경로만 존재한다.  
- 노드의 자료형은 어떠한 것이라도 가능하다.  
```Kotlin
  data class PersonInfo(var name:String, var age:Int)
  
  class Node {
      var Index:Int
      var person:PersonInfo
  }
```  
  
### 트리 관련 용어
앞으로 쓰실 트리 관련 개념들에 대해서, 사용하실 용어와 그 의미를 여기서 정해주세요.  
- `Node` : 노드. 트리를 구성하고 있는 각 요소
- `Edge` : 간선, 트리를 구성하기 위해 노드와 노드를 연결하는 선
- `Root Node` : 루트 노드, 최상위 계층에 존재하는 노드
- `level` : 레벨, 트리의 특정 깊이를 가지는 노드의 집합
- `degree` : 차수, 하위 트리 개수 / 간선 수 (degree) = 각 노드가 지닌 가지의 수
- `Parent` : 부모 노드, 부속 트리(subtree)를 가진 노드
- `Child` : 자시 노드. 부모에 속하는 부속노드
- `Sibling` : 형제 노드, 부모가 같은 자식 노드들
- `Ancestor` : 조상 노드, 노드의 부모 노드들의 총 집합
- `Descendant` : 자손 노드, 노드의 부속 트리에 있는 모든 노드들
- `Terminal Node` ( = leaf Node) : 잎새 노드, 하위에 다른 노드가 연결되어 있지 않은 노드
- `Internal Node` ( = 비단말 노드): 내부 노드, 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.

## 이진트리
### 개념
`이진트리(Binary Tree)`란 각 노드가 최대 2개의 `자식 노드`만 갖는 트리를 의미한다.  
- `이진트리`라면 레벨 i에서 가질 수 있는 최대 노드의 수는 `2^i`이다. (i >= 0)  

### 이진트리 분류
이진트리는 `포화이진트리(full binary tree)`, `완전이진트리(complete binary tree)`, `균형이진트리(balanced binary tree)` 등이 있다.  
  
#### 정이진트리(full binary tree)
![포화이진트리](https://i.imgur.com/edCd7lU.png)  
`잎새 노드를 제외한 모든 노드들이 2개의 자식 노드`를 갖고 있는 트리를 의미한다.  
정이진트리는 `레벨 i` 에서 `2^i`개 만큼 노드의 수를 가지며, 전체 노드의 개수는 `2^(i+1) - 1`개 이다.  

![완전이진트리](https://i.imgur.com/mXssEqj.png)  
`완전이진트리`는 `마지막 레벨을 제외한 모든 레벨에서 노드들이 2개의 자식 노드`를 갖고 있는 트리를 의미한다.  
완전이진트리는 `레벨 i`에서 노드의 수 `N <=  2^(i+1)` 개 가 성립한다.  
`완전이진트리`의 한 종류로 `포화이진트리` 가 존재한다.  
  
이외에도 한쪽 방향으로만 자식노드가 있는 `편향이진트리`, 모든 노드가 0개 또는 2개의 노드만 갖고있는 `정이진트리`  
모든 노드의 왼쪽과 오른쪽의 서브트리가 레벨이 1밖에 차이가 안나는 `군형이진트리` 등이 있다. 
![편향이진트리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVSKoo%2FbtqENrxMl4A%2FKTrSCL5jqHrrfsELInGyJ1%2Fimg.png)  
편향이진트리 예시  
  
![정이진트리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4QZig%2FbtqEOOTLqzF%2FLNm7UTV7Powqylx8K6iO21%2Fimg.png)  
균형이진트리 예시  
  
![균형이진트리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FPAT06%2FbtqEOEEVkc2%2FUTAWwMMRzxXkhyzZZjd9EK%2Fimg.png)  
  
### 트리 표현법
배열 표현법과 링크 표현법에 대해서 작성해주세요.  
필요하다면 코드도 함께 작성해주세요.


## 순회

### 개념
`트리순회(tree traversal)`란 트리의 각 노드를 체계적인 방법으로 방문하는 과정을 말한다.  
각 노드를 단 한번씩만 방문하여 모든 노드를 방문하는 것을 목표로 하며, 방법에 따라 `전위 순회`, `중위 순회`, `후위 순회`로 나눈다.  
  
이진트리에서 순회는 다음 3개의 세부작업을 거치게 된다.  
1. 현재 노드를 방문하여 처리  
2. 현재 노드의 왼쪽 서브 트리로 이동  
3. 현재 노드의 오른쪽 서브 트리로 이동  
  
### 종류
#### 전위순회
![전위순회](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdKFUGw%2FbtqESVTtY70%2FalR3Hghb4nRJrIcF2mTuX0%2Fimg.png)  
  
전위 순회는 깊이 우선 순회(DFT, Depth-First Traversal)이라고도 한다.
   
`트리를 복사`하거나, `전위 표기법`을 구하는데 주로 사용됩니다.
트리를 복사할때 전위 순회를 사용하는 이유는 `트리를 생성할 때 자식 노드보다 부모 노드가 먼저 생성`되어야 하기 때문입니다.
  
전위 순회는 다음과 같은 방법으로 진행합니다.  
1. Root 노드를 방문한다.  
2. 왼쪽 서브 트리를 전위 순회한다.  
3. 오른쪽 서브 트리를 전위 순회한다.  
  
#### 중위순회
![중위순회](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbKpFtI%2FbtqESWdQoEy%2FMffuYG3K9pXNKY1Ejf5n2K%2Fimg.png)  
  
중위 순회는 왼쪽 오른쪽 대칭 순서로 순회를 하기때문에 대칭 순회(symmetric traversal)라고도 한다.   
중위 순회는 이진 탐색트리(BST)에서 오름차순 또는 내림차순으로 값을 가져올 때 사용된다.  
  
`중위순회` 는 `잎새 노드` 에서 `부모 노드`로, 다시 시작했던 `잎새 노드의 형제노드로` 를 반복하는 순회이다.  
다마 중위순회라고 `H`부터 시작하는 게 아니라, 똑같이 `루트 노드`, `A`부터 시작한다  
  
단, 하지만 중위 순회에서는 만약 자기 자신한테 왼쪽 노드가 있다면 자기 처리를 미루고 왼쪽부터 이동한다
즉, 처음에 A->B->D->H 순으로 쭉 내려와서 H를 출력, D와 B 출력  
E가 있으므로 E로 다시 내려가지만 E는 왼쪽 자식이 있으니까 I부터 출력, E출력, J출력  
이런 식으로 진행된다  
  
전체적인 방법은 다음과 같다.  
1. 왼쪽 서브 트리를 중위 순회한다.  
2. Root 노드를 방문한다.   
3. 오른쪽 서브 트리를 중위 순회한다.  
  
#### 후위순회
![후위순위](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmLXYK%2FbtqESV62keo%2FySEmIDkEMk14Ouull1d7kk%2Fimg.png)  
  
후위 순회는 트리를 삭제하는데 주로 사용된다.  
이유는 부모노드를 삭제하기 전에 자식 노드를 삭제하는 순으로 노드를 삭제해야 하기 때문이다.  
   
후위 순회는 다음과 같은 방법으로 진행합니다.  
1. 왼쪽 서브 트리를 후위 순회한다.
2. 오른쪽 서브 트리를 후위 순회한다.
3. Root 노드를 방문한다.  

## 그리디 알고리즘

### 개념
그리디 알고리즘은 문제를 작은 단위로 나눈 다음, 작은 단위에서의 최적의 답만을 결정하여 마지막 해답까지 이르는 방법을 의미한다.  
해당 상황에서 가장 좋은 답을 정하는 것이기 때문에, 가장 최적한 답이 보장되지 않는다.    
  
[동적 계획법(Dynamic Programming)과 탐욕법(Greedy Algorithm)](https://media.vlpt.us/post-images/cyranocoding/c8b8eff0-b228-11e9-89af-8fc0a61dbc3e/1CeFxqV8wFf2NaQm1hqYGMQ.png)  
대표적인 예시로, 다음 트리에서 가장 큰 숫자는 `99` 이지만 그리디 알고리즘으로 따라가면 `12`가 나오게 된다.  
  
Greedy의 가장 큰 장점은 계산 속도에 있다. 따라서 그리디 알고리즘의 조건에 부합하는 몇몇의 문제에서는 최적해를 빠르게 산출해낼 수 있다.
빠른 계산 속도의 장점으로 이전에 언급하 다이나미 프로그래밍과 서로 보완하는 개념으로 알려져 있다.  

### 사용조건
#### 탐욕적 선택조건  
앞의 선택이 뒤의 선택에 영향을 미쳐서는 안된다.  
즉, 방문처리를 진행하는 DFS, BFS 의 경우 그리디 알고리즘에 사용할 수 없게 된다.  
   
#### 최적 부분 구조 조건  
작은 부분에서 구한 최적의 답으로 큰 문제의 최적의 답을 구할 수 있어야 한다.  
즉 큰 문제의 정답을 작은 문제의 정답에서 부터 구할 수 있는 구조여야 한다.  
   
  
### 코드 예시
동전 문제
 
1원, 50원, 100원, 500원 동전이 주어질 때, 가장 적게 지불하는 동전의 수를 구하기  
  
```Kotlin
private fun Int.coinProblem(list: List<Int>) : Int {
	//외부로부터 숫자를 전달받을 때 항상 고정값이므로 Int.함수명을 이용

	//항상 최적을 따라야 하기 때문에 가장 큰 숫자부터 내림차순으로 정렬
	val coinList = list.sortedDescending()


    var coinCount = 0	// 전체 코인 수
    var money = this	// this는 Int.coinProblem을 뜻함
    var coinNum: Int	// 각각의 코인마다 소모된 수
    
    
    for(coin in coinList) {
        coinNum = money / coin
        coinCount += coinNum	

        money -= coinNum * coin	// 코인의 양 * 코인 
    }

    return coinCount
}

fun main() {
    val coinList = listOf(1,100,50,500)
    
    println(거슬러주고 싶은 돈.coinProblem(coinList))
}
```
## 참고

[이렇게 참고를 넣어주세요.](https://somewhere_over_the_rainbow)
[트리(tree)와 이진트리(binary tree)](https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/)
[자료구조 이진 트리(Binary Tree)의 종류](https://hsc-tech.tistory.com/7)
[5-2. \[자료구조\] 이진트리(binary tree)](https://kingpodo.tistory.com/27)
[\[자료구조\] 트리(Tree)란](https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html)
[트리(Tree) 자료구조](http://dblab.duksung.ac.kr/ds/pdf/Chap08.pdf)
[완전이진트리 vs 포화이진트리 : 이 둘에 대해 알아봅시다.](https://codingdog.tistory.com/entry/완전이진트리-vs-포화이진트리-이-둘에-대해-알아봅시다)  
[자료구조-트리 순회(전위 순회, 중위 순회, 후위 순회)](https://foxtrotin.tistory.com/187)  
[https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/](https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/)  
[\[자료구조\] 트리 순회 (Tree Traversal)](https://yoongrammer.tistory.com/70)  
[\[자료구조\] 이진 탐색 트리 (BST, Binary Search Tree)](https://yoongrammer.tistory.com/71?category=956616)
[\[Kotlin\] 그리디 알고리즘(탐욕 알고리즘)](https://minoflower.tistory.com/4)  
[\[알고리즘\] 탐욕 알고리즘(Greedy Algorithm)](https://hanamon.kr/알고리즘-탐욕알고리즘-greedy-algorithm/)  
[동적 계획법(Dynamic Programming)과 탐욕법(Greedy Algorithm)](https://velog.io/@cyranocoding/동적-계획법Dynamic-Programming과-탐욕법Greedy-Algorithm-3yjyoohia5)
