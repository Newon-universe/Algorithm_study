# 분할정복(Divide and Conquer)    
---   

### 1. 개념     
문제를 나눌 수 없을 때까지 나눈 다음, 나누어진 문제들을 해결해  문제의 답을 얻는 귀납적 알고리즘 풀이방법이다.
    
        
            
 <br></br>
     
         
           

### 2. 특징    
하나의 문제를 여러 문제로 쪼개어 푼다는 특징이 있다. 쪼개어진 문제들을 다시 쪼갤 수 있다면 더 이상 쪼개지지 않을 때까지 반복한다.


 <br></br>
          




### 3. 장단점     
- 장점 : 큰 문제를 한 번에 해결하려고 하면, 문제를 풀다가 헷갈려서 어떤 풀이 단계까지 왔는지 혹은 다음 풀이단계는 무엇인지 혼동이 오는 경우가 있는데 문제를 쪼개어 풂으로써 풀이단계를
단순화 시킬 수 있어 혼동을 피할 수 있다는 장점이 있다.
- 단점 : 문제를 더 이상 쪼갤 수 없을 때까지 쪼개고, 합치는 단계에 따라 문제를 풀기 때문에 풀이 단계가 몇 겹이 될지 모르기 때문에 기본적으로 시간이 오래 걸린다.
시간과 더불어서 풀이 단계만큼 스택에 많은 데이터를 저장하므로 스택 오버플로우가 발생하거나 과도한 메모리 사용을 하게 된다는 단점도 있다.
분할한 문제들과 원래 문제의 유사성이 없는 문제라면 이 풀이 적용할 수 없다.
     
 <br></br>     



### 4. 분할정복 알고리즘의 처리과정(문제해결과정-기본로직)     
- 분할 : 주어진 문제를 여러 개의 작은 문제로 분할
- 정복 : 작은 문제들을 순환적으로 분할하고 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제에 대한 해를 구함
- 결합 : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구함



 <br></br>     
          




### 5. 시간복잡도     
분할 정복 알고리즘의 수행시간은 문제마다 다 다르다.
시간복잡도가 나누어지는 문제의 개수, 분할 후 문제의 크기, 각 문제마다 병합(정복) 단계에서 걸리는 시간들에 의해 결정되기 때문.




 <br></br>
      
         



### 6. 분할정복 방법이 적용된 병합 정렬(Merge sort), 퀵 정렬(Quick sort)에서의 분할 과정      
- 병합 정렬 (Merge sort)
![img](https://blog.kakaocdn.net/dn/bL9LCR/btq54nCwwSR/a41SK3K2vFwi0ZknuDknv1/img.gif)
합병 정렬은 배열이 1개가 될 때까지 계속 쪼갠다음 다시 합병 & 정렬을 하며 배열을 완성시키는 방법이다.
위 그림처럼 절반으로 뚝 뚝 분할하다가 각각의 원소가 1개가 되면 대소 비교를 통해 정렬하면서 합병을 하면 된다. 


- 퀵 정렬 (Quick sort)
![img](https://t1.daumcdn.net/cfile/tistory/996DAB335ACC1BDF16)
퀵 정렬은 n개의 데이터를 정렬할 때, 최악의 경우에는 O(n2)번의 비교를 수행하고, 평균적으로 O(n log n)번의 비교를 수행한다.
위 그림처럼 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소(빨갛게 변하는 막대)를 피벗이라고 한다.
피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 
피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 돌면서, 모든 원소가 정렬될 때까지 이 과정을 반복한다.


 <br></br>
     
     
### 7. 동적 계획법(Dynamic Programming)과 분할정복법(Divide and Conquer) 비교
- 공통점 : 문제를 쪼개어 해결한다는 것.
- 차이점 : DP는 쪼개어진 문제들의 해가 그 다음 문제의 요소로 쓰인다. 피보나치 수열을 생각해보면, 직전의 2개의 수의 합이 다음 합의 요소로 쓰이는 원리다. 다음 풀이단계가 직전의 해에 의존적이라는 소리다.
직전의 해를 모르면 다음 단계를 진행할 수 없다. 
예를 들어, 1부터 10까지 10단계의 풀이단계가 있다고 하면, 2단계를 풀기 위해서는 1단계의 해를 알아야하고, 3단계를 풀기 위해서는 2단계의 해를 알아야 하는 방식이다.
반대로 분할정복은 쪼개어진 문제들이 각각 독립적으로 쓰이기 때문에 다음 풀이에 영향을 미치지 않는다. 위의 정렬 예시만 봐도 알 수 있듯이, 작게 쪼개진 원소값들은 정렬이 되고나면 그 문제는 끝이다.
DP처럼 다시 재활용된다거나 정렬이 다음 정렬에 영향을 미치지 않는다는 뜻이다.
예를 들어, 1부터 10까지 10단계의 풀이단계가 있다고 하면, 1단계를 풀면 끝. 뒤돌아보지 않는다. 그 다음 2단계 끝. 그 다음 3단계 끝. 이렇게 10단계까지 풀이하는 방식이다.

 <br></br>

### 8. 참고할만한 그림을 넣어주세요.

<img width="575" alt="캡처" src="https://user-images.githubusercontent.com/75516061/140600493-c4c4b790-0f5a-4a6f-8d51-42627f27d258.PNG">
(화질구지..)
가장 단순하게 두 알고리즘을 잘 표현한 그림이다. 둘 다 문제를 쪼갠다는 공통점에서 유사한 이진트리 그래프가 그려지지만,
각 노드가 부모 노드에게 영향을 미치나 안 미치나에 따라 간선의 방향성이 달라진다는 의미의 그림이다.


 <br></br>



---  
### 참고     
https://bestinu.tistory.com/14 
https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC
http://ivis.kr/images/0/09/5%EC%9E%A5%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.pdf

