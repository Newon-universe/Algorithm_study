

## 이분 탐색 / 이진 탐색 (Binary Search)

### ① 개념
**정렬된 배열 또는 리스트에 적합한 고속 탐색 방법**이다.

-   배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄인다.
-   찾고자 하는 값이 속해있지 않은 부분은 전혀 고려할 필요가 없기 때문에, 매 단계에서 검색해야 할 리스트의 크기를 반으로 줄일 수 있다.
-   이러한 방법을 반복적으로 사용해 탐색하는 방법이 이진 탐색이다.
-   데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않고, 주로 고정된 데이터에 대한 탐색에 적합하다.

### ② 구현과정 및 구현조건
![이진탐색 ( 이분탐색, Binary Search)의 모든 것](https://blog.kakaocdn.net/dn/bCRI11/btqDEFKLWFh/Fh5mKeR8p6YxJ1lhKAiJYk/img.gif)

-  1. 탐색의 대상이 되는 자료들이 array[low] 에서부터 array[high]에 들어있다고 가정하자. (정렬되어 있어야 함)
	- 즉 어떤 시점에서 탐색되어야 할 범위는 low에서 high 까지가 된다.
	- 맨 처음 low에는 0번 인덱스의 값, high에는 n-1번 인덱스의 값이 들어갈 것이다.
	<br/>
- 2. low와 high값에 의거해  중간값 mid 값은 (low + high) / 2이다.
	- 즉, array[low] ~ array[high] 까지의 탐색은 array[low] ~ array[middle-1] +  array[middle+1] + array[high]까지의 탐색이 된다.
	<br/>
- 3. array[mid] 값과 구하고자 하는 key값을 비교한다.
	- 3-1. key > mid :  구하고자 하는 값이 중간값보다 높다면 low를 mid +1로 만들어 줌 (왼쪽 반을 버림)
	- 3-2. key < mid : 구하고자하는 값이 중간값 보다 낮다면 high를 mid-1로 만들어 줌 (오른쪽 반을 버림)
	- 3-3. key == mid : 구하고자 하는 값을 찾음 중간값 리턴 
<br/>
- 4. low > high가 될 때까지 1~3번을 반복하면서 구하고자 하는 값을 찾는다.
(이때까지 못 찾으면 탐색 실패 -1, false, error 등 return)


### ③ 코드(반복문)
> Java
```java
int binarySearch2(int key, int low, int high) {
	int mid;

	while(low <= high) {
		mid = (low + high) / 2;

		if(key == arr[mid]) {
			return mid;
		} else if(key < arr[mid]) {
			high = mid - 1;
		} else {
			low = mid + 1;
		}
	}

	return -1; // 탐색 실패 
}
```

### ④ 코드(재귀)
> Java
```java
int binarySearch1(int key, int low, int high) {
	int mid;

	if(low <= high) {
		mid = (low + high) / 2;

		if(key == arr[mid]) { // 탐색 성공 
			return mid;
		} else if(key < arr[mid]) {
			// 왼쪽 부분 arr[0]부터 arr[mid-1]에서의 탐색 
			return binarySearch1(key ,low, mid-1);  
		} else {
			// 오른쪽 부분 - arr[mid+1]부터 arr[high]에서의 탐색 
			return binarySearch1(key, mid+1, high); 
		}
	}

	return -1; // 탐색 실패 
}
```

### ⑤ 시간복잡도  
▷ `O(logN)`
<br/>

### ⑥ 장단점  
▷ 장점 : 검색이 반복될 때마다 목표값을 찾을 확률은 두 배가 되므로 속도가 빠르다  

▷ 단점 : 검색 원리상 정렬된 리스트에만 사용할 수 있다
<br/>


## 정렬

### ① 정렬의 종류와 개념
▷ **선택정렬**
- Step 1. 주어진 리스트에서 최솟값을 찾는다.

- Step 2. 최솟값을 맨 앞 자리의 값과 교환한다.

- Step 3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.
<br/>

▷**삽입정렬** (오름차순 기준)
- Step 1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. 
	- 첫 번째 타겟은 두 번째 원소부터 시작한다.

- Step 2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.

- Step 3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.
<br/>

▷ **버블정렬** (오름차순 기준)
- Step 1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.

- Step 2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.

- Step 3. 다음 원소로 이동하여 해당 원소와 그 다음 원소를 비교한다.
<br/>

### ② 구현과정 및 구현조건

> **선택정렬** </br>
> ![](https://blog.kakaocdn.net/dn/qjbEC/btqNiW4IUsW/6XCnYWRkk437W3kQYBDlP1/img.gif)

> **삽입정렬** </br>
> ![](https://blog.kakaocdn.net/dn/bxvpd6/btqOuH69gZU/s5NmD45Lo0HaI80sK9QXt1/img.gif)

> **버블정렬** </br>
> ![](https://blog.kakaocdn.net/dn/camFmC/btqT18jLl9k/eewEO8cGnwQ0mopwu18r91/img.gif)

```
// 선택정렬
selectionSort(A[], n) {  
	for last <- n downto 2 {                              == 1  
		 A[1,...,last] 중 가장 큰 수 A[k]를 찾는다;               == 2  
		 A[k] <-> A[last];  // A[k]와 A[last]의 값을 교환       == 3  
	}  
}

// 삽입정렬
insertionSort(A[], n) { // 배열 A[1...n]을 정렬한다.
	for i <- 2 to n                       == 1
	    A[1...i]의 적당한 자리에 A[i]를 삽입한다.  == 2
}

// 버블정렬
bubbleSort(A[], n) {
	for last <- n downto 2 {                    == 1
	    for i <- to last-1                        == 2
		    if (A[i] > A[i+1]) the A[i] <-> A[i+1]; == 3
	}
}
```

### ③ 코드(반복문)
> Java
```java
// 선택정렬
public void selectionSort(int a[]) {
        for(int i=0; i<a.length-1; i++) {
            int min = i;
            for(int j=i+1; j<a.length; j++) { 
                if(a[j] < a[min]) { //오름차순 
                    min = j;
                }
            }
            swap(a, min, i); 
            System.out.printf("\n선택 정렬 %d 단계 : ", i+1);
            for(int v : a) {
                System.out.printf("%3d ", v);
	        }
        //System.out.println(Arrays.toString(a));            
        }
        System.out.println();
}

// 삽입정렬
public void insortionSort(int a[]) {
        int size = a.length;        
        for(int i=1; i<size; i++) {
            int temp = a[i];
            int j = i;
            while((j>0) && (a[j-1]>temp)) {
                a[j] = a[j-1];
                j--;
            }
            
            a[j] = temp;
            System.out.printf("\n삽입정렬 %d 단계 : ",i);
            for(int v : a) {
                System.out.printf("%3d ", v);
            }            
        }
        System.out.println();
}

// 버블정렬
public void bubbleSort(int a[]) {
        int size = a.length;
        for(int i=size-1; i>0; i--) {
            System.out.printf("\n버블 정렬 %d 단계 : ", size-i);
            for(int j=0; j<i; j++) {
                if(a[j] > a[j+1]) {
                    swap(a,j,j+1);
                }
                System.out.printf("\n\t");
                for(int v : a) {
                    System.out.printf("%3d ", v);
                }
            }            
        }
        System.out.println();
}
```

### ⑤ 각 정렬방법의 시간복잡도  

※ 53412 를 오름차순으로 정렬하는 경우 </br>
▷ 선택정렬 : `O(N^2)`</br>
▷ 삽입정렬 : `O(N^2)`</br>
▷ 버블정렬 : `O(N^2)`</br>
<br/>

### ⑦ 참고
#### 이분 탐색 / 이진 탐색 (Binary Search)
[이진탐색 = 이분탐색 (Binary Search)](https://minhamina.tistory.com/127) </br>
[마이구미의 HelloWorld](https://mygumi.tistory.com/72) 

#### 정렬
[개발자의 기록습관](https://ict-nroo.tistory.com/52) </br>
[자바 [JAVA] - 삽입 정렬 (Insertion Sort)](https://st-lab.tistory.com/179)
