

## 이분 탐색 / 이진 탐색 (Binary Search)

### ① 개념
**정렬된 배열 또는 리스트에 적합한 고속 탐색 방법**이다.

-   배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄인다.
-   찾고자 하는 값이 속해있지 않은 부분은 전혀 고려할 필요가 없기 때문에, 매 단계에서 검색해야 할 리스트의 크기를 반으로 줄일 수 있다.
-   이러한 방법을 반복적으로 사용해 탐색하는 방법이 이진 탐색이다.
-   데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않고, 주로 고정된 데이터에 대한 탐색에 적합하다.

### ② 구현과정 및 구현조건

**그림 첨부해서 설명해주실 분들은 여기에 넣어주세요**

```
sudo 코드로 설명하실분은 여기에 넣어주세요!
```

### ③ 코드(반복문)
> Java
```java

```

### ④ 코드(재귀)
> Java
```java

```

### ⑤ 시간복잡도  
▷ 
<br/>

### ⑥ 장단점  
▷ 
<br/>


## 정렬

### ① 정렬의 종류와 개념
▷ **선택정렬**
- Step 1. 주어진 리스트에서 최솟값을 찾는다.

- Step 2. 최솟값을 맨 앞 자리의 값과 교환한다.

- Step 3. 맨 앞 자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.

▷**삽입정렬** (오름차순 기준)
- Step 1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다. 
	- 첫 번째 타겟은 두 번째 원소부터 시작한다.

- Step 2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.

- Step 3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.

▷ **버블정렬** (오름차순 기준)
- Step 1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.

- Step 2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.

- Step 3. 다음 원소로 이동하여 해당 원소와 그 다음 원소를 비교한다.

### ② 구현과정 및 구현조건

> **선택정렬**
> ![](https://blog.kakaocdn.net/dn/qjbEC/btqNiW4IUsW/6XCnYWRkk437W3kQYBDlP1/img.gif)

> **삽입정렬**
> ![](https://blog.kakaocdn.net/dn/bxvpd6/btqOuH69gZU/s5NmD45Lo0HaI80sK9QXt1/img.gif)

> **버블정렬**
> ![](https://blog.kakaocdn.net/dn/camFmC/btqT18jLl9k/eewEO8cGnwQ0mopwu18r91/img.gif)

```
// 선택정렬
selectionSort(A[], n) {  
	for last <- n downto 2 {                              == 1  
		 A[1,...,last] 중 가장 큰 수 A[k]를 찾는다;               == 2  
		 A[k] <-> A[last];  // A[k]와 A[last]의 값을 교환       == 3  
	}  
}

// 삽입정렬
insertionSort(A[], n) { // 배열 A[1...n]을 정렬한다.
	for i <- 2 to n                       == 1
	    A[1...i]의 적당한 자리에 A[i]를 삽입한다.  == 2
}

// 버블정렬
bubbleSort(A[], n) {
	for last <- n downto 2 {                    == 1
	    for i <- to last-1                        == 2
		    if (A[i] > A[i+1]) the A[i] <-> A[i+1]; == 3
	}
}
```

### ③ 코드(반복문)
> Java
```java
// 선택정렬
public void selectionSort(int a[]) {
        for(int i=0; i<a.length-1; i++) {
            int min = i;
            for(int j=i+1; j<a.length; j++) { 
                if(a[j] < a[min]) { //오름차순 
                    min = j;
                }
            }
            swap(a, min, i); 
            System.out.printf("\n선택 정렬 %d 단계 : ", i+1);
            for(int v : a) {
                System.out.printf("%3d ", v);
	        }
        //System.out.println(Arrays.toString(a));            
        }
        System.out.println();
}

// 삽입정렬
public void insortionSort(int a[]) {
        int size = a.length;        
        for(int i=1; i<size; i++) {
            int temp = a[i];
            int j = i;
            while((j>0) && (a[j-1]>temp)) {
                a[j] = a[j-1];
                j--;
            }
            
            a[j] = temp;
            System.out.printf("\n삽입정렬 %d 단계 : ",i);
            for(int v : a) {
                System.out.printf("%3d ", v);
            }            
        }
        System.out.println();
}

// 버블정렬
public void bubbleSort(int a[]) {
        int size = a.length;
        for(int i=size-1; i>0; i--) {
            System.out.printf("\n버블 정렬 %d 단계 : ", size-i);
            for(int j=0; j<i; j++) {
                if(a[j] > a[j+1]) {
                    swap(a,j,j+1);
                }
                System.out.printf("\n\t");
                for(int v : a) {
                    System.out.printf("%3d ", v);
                }
            }            
        }
        System.out.println();
}
```

### ⑤ 각 정렬방법의 시간복잡도  
※ 53412 를 오름차순으로 정렬하는 경우
▷ 선택정렬
▷ 삽입정렬
▷ 버블정렬
<br/>

### ⑦ 참고
#### 이분 탐색 / 이진 탐색 (Binary Search)

#### 정렬
[개발자의 기록습관](https://ict-nroo.tistory.com/52) </br>
[자바 [JAVA] - 삽입 정렬 (Insertion Sort)](https://st-lab.tistory.com/179)
