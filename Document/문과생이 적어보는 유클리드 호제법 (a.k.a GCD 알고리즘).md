# 문과생이 적어보는 유클리드 호제법 (a.k.a GCD 알고리즘)
### 유클리드 호제법 == 나눗셈 알고리즘으로 최대 공약수 구하기
작성자 : 뉴원 (Newon)<br/><br/>
유클리드 호제법이란 <br/>
두 정수 `a, b`ﾠﾠ|ﾠﾠ   a 와 b 의 `최대공약수 𝒹`  ﾠﾠ|ﾠﾠ  a / b 했을 때 나오는 `나머지 𝛾`  ﾠﾠ|ﾠﾠ  이 있을 때  <br/>
<br/>
>`𝒹 = gcd(a, b) = gcd(b, 𝛾)` 가 성립함을 의미한다. <br/>
> _이때 gcd(a, b) 는 a 와 b 사이의 최대공약수를 뜻한다._
<br/>

이때 `𝒹 = gcd(a, b) = gcd(b, 𝛾)` 를 확장해서 `𝛾´`이 `b를 𝛾로 나누었을때의 나머지`라고 한다면 <br/> 
`𝒹 = gcd(a, b) = gcd(b, 𝛾) = gcd(𝛾, 𝛾´) ... ` 이 성립하게 된다. <br/>
이 성질을 이용해서 알고리즘에서 최대공약수를 구할 때 gcd 를 구하는 함수를 만들고, 이를 for 문이나 재귀함수로 반복해서 푸는 방법이 성립하게 된다.</br>
<br/>

이를 간단하게 코드로 작성하면 다음과 같이 나타난다. <br/>
```Kotlin

fun Gcd(a:Int, b:Int):Int {
    var r = a % b
    if (r == 0)
       return b
    else
       return Gcd(b, r)
}

fun main() {
    val br = System.`in`.bufferedReader()
    val (a,b) = br.readLine().split(' ').map {it.toInt()}
    
    var gcd = Gcd(a,b)
    println(gcd)                                               // a 와 b 의 최대공약수
    println(a*b/gcd)                                           // a 와 b 의 최소공배수
    
/* 
*    백준 2609, 최대공약수와 최소공배수 문제이다.
*    코틀린으로 작성되었다.
*/
```
<br/>
<br/>


### 이게 왜 됨?
글의 본문이다. 왜 될까? <br/>
<br/>
<center>
<img 
src="https://mblogthumb-phinf.pstatic.net/MjAxODEwMTFfMTYw/MDAxNTM5MjI1OTcxODc5.WnNZInoiz0MY7txOJLbGB_IJ-OGoJfKqDOGxfV_DSi8g.IMZ0kIqROr2lmavgFniMfueg4htsBZj33S5oaaLwUKsg.GIF.pola0216/source.gif?type=w800" width="200" height="200"/>
</center>
<br/>

***a, b, 𝛾(= a와 b의 나머지) 에는 무슨 관계가 있길래 gcd(a,b) 와 gcd(b,𝛾) 과 같고, 𝛾가 𝛾의 나머지(𝛾´) 의 최대공약수, gcd(𝛾, 𝛾´)와 같고 <br/>이걸 { ... } 반복해도 성립하게 되는걸까?<br/>
<br/>
이게 왜 되는지 이해해보는 것이 이 글의 목표이다.***<br/>
<br/>

두 정수 `a, b`가 있고 `a > b` 이면서, `𝒹(최대공약수)` 를 지니고 있는 수를 통해 알아보자. ﾠﾠﾠﾠﾠ ﾠﾠﾠﾠﾠ ﾠﾠﾠﾠﾠﾠ`대전제 = a 와 b 의 최대공약수 𝒹`<br/>
우선 우리는 a 와 b 의 최대공약수 𝒹를 알고 있으니, a 와 b 를 다음과 같이 바꿔본다.<br/>
> `a = 𝒹 * ⍺`<br/>
> `b = 𝒹 * β`<br/>
> ⍺와 β는 𝒹를 곱했을 때 각각 a 와 b 가 나오는 정수
<br/>

그럼 우린 다음과 같이 쓸 수 있다.<br/>
> `a = q * b + 𝛾`ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠq 는 a / b 의 목,ﾠ 𝛾 은 나머지이다.<br/>
> `𝒹 * ⍺ = q * 𝒹 * β + 𝛾`ﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠa  를 𝒹 * ⍺로,ﾠ b 를  𝒹 * β 로 치환했다.ﾠﾠﾠﾠ ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ⍺와 β는 조건을 만족하는 임의의 수<br/>
> `𝛾 = 𝒹 (⍺ - q * β)`ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠ위의  식을  𝛾  과  나머지로  정리하였다.<br/>
> `𝛾 = 𝒹    *   (⍺ - q * β)`ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠ?!ﾠﾠ 𝛾 ﾠ로 정리하였더니,ﾠ  𝒹  *  (⍺ - q * β) 의 형태이므로,ﾠ 𝛾 의 약수에도 𝒹 가 들어감을 알 수 있다 !! 
<br/>
올, 위와 같이 정리하였더니 우리는 𝛾 의 약수에 a 와 b 의 최대공약수인 𝒹가 있음을 알 수 있었다!! <br/>

그렇다면, `𝒹는 b 와 𝛾 의 최대공약수`이기도 할까?<br/>
<br/>

*그렇다, 이것이 이 글의 `핵심 주제 ①`이다.*<br/>
`𝒹는 a 와 b 와 𝛾의 최대공약수`가 참인지 거짓인지 확인하는 것이 오늘 주제의 `핵심 주제` 중 하나이다.<br/>
<br/>
*미리 스포하자면 핵심 주제는 `핵심 주제 ② (crazy_𝛾은 언젠가는 0이 될 수 밖에 없다)` 까지 있다.*

<br/>

우리는 현재 `a` 와 `b` 의 `최대공약수가 𝒹` 라는 것을 알고 있으며 `𝛾 에도 𝒹라는 공약수`가 들어간다는 것을 안다. <br/>

이때 **𝛾 에게 있어서도 𝒹가 최대공약수가 된다면** <br/>
우리는 `a 와 b 와 𝛾 의 최대공약수가 𝒹 로 같다`는 것을 알 수 있게 된다 !!<br/>
<br/>

---
### 𝛾 의 최대공약수가 a와 b의 최대공약수인 𝒹 와 같다는 동화 .. 가능 ?
<img 
src="https://i.ibb.co/6g18SfS/Kakao-Talk-Photo-2021-09-30-20-47-35.gif" width="200" height="200"/><br/>

인생은 호락호락하지 않다, 그리고 우리는 𝒹가 𝛾의 최대공약수라고 확신할 수 없다. <br/>
확신할 수 없으니 ***𝒹 가 𝛾의 최대공약수가 아님*** 이라고 가정해보자.ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ ﾠ`대 가정 = 𝒹 가 𝛾의 최대공약수가 아님`<br/>
<br/>
𝛾의 최대공약수가 𝒹 가 아니라면, 𝛾 의 최대공약수는 그 어떤 임의의 수 `𝒹´` 일 것이다.<br/>
잠시 정리해서<br/> 
- 𝒹 = gcd(a,b) 이고 𝒹´ = gcd(b, 𝛾) 이라면<br/>
- 𝒹´ 는 언제나 𝒹 보다 작아야한다.ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ`조건 ① = (𝒹 < 𝒹´)`<br/>
- 왜? `대 가정`에 의해서 𝒹 는 𝛾 의 최대공약수가 아니고, 𝒹´ 가 𝛾 의 최대공약수이어야 하기 때문이다.<br/>

현재 우리는 `대 가정`과 `조건 ①`를 갖고 있다. <br/>
<br/>

그럼, 𝒹´의 관점에서 b 와 𝛾를 다시 써보자.<br/>
> b = 𝒹´ * b´ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠb´은  b = 𝒹´ * b´ 를 만족하는 수<br/>
> 𝛾 = 𝒹´ * r´ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ//ﾠﾠr´은 𝛾 = 𝒹´ * r´를 만족하는 수<br/>
<br/>

이걸 위에서 사용했던 `a = q * b + 𝛾`ﾠﾠﾠ에 대입해보자. <br/>
> a = q * 𝒹´ * b´ﾠ+ 𝒹´ * r´ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ// b 와 r 에 𝒹´에서 본 b 와 r 를 넣었다.<br/>
> a = 𝒹´ * (q * b´ + r´)ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ// 넣어본 김에 깔끔하게 𝒹´로 정리해보았다.<br/>
<br/>

어 ? a 의 공약수에도 𝒹´가 들어간다.<br/>
하지만 알다시피, 대전제로 우리는 a 와 b 의 최대공약수 𝒹 라고 하였으며, <br/>
또 따라서 𝒹´는 𝒹 보다 작을 수 밖에 없다 !!ﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠﾠ`조건 ② = (𝒹´ < 𝒹)`<br/>
<br/>
<br/>
? `조건 ① = (𝒹 < 𝒹´)` 과 `조건 ② = (𝒹´ < 𝒹)` 이 모순된다. <br/>
문과인 나도 안다. **어떠한 정수 𝒹가 𝒹´ 보다 작으면서 클 수는 없다** <br/>
<br/>
그렇다면 잘못된 건 `대 가정 = 𝒹 가 𝛾의 최대공약수가 아님` !! <br/>
해당 가정의 결론이 거짓이니, 그 가정의 반대는 참 ! 즉 `𝒹 는 𝛾의 최대공약수임`<br/>
<br/>
무슨소리냐고? <br/>
다음 gif를 참고해보자.

<br/>
<br/>

따라서 우리는 `a 와 b 와 𝛾 의 최대공약수가 𝒹로 같다.` 는 이야기가 동화인 줄 알았지만 <br/>
사실 팩트기반 실제 사례 기반 수필로써 `핵심주제 ① : a 와 b 와 𝛾 의 최대공약수가 𝒹로 같다.` 가 True임을 알 수 있었다.<br/>

---
### ㅇㅋ, 근데 왜 a 와 b 와 𝛾 의 최대공약수가 같다고 그걸 저렇게 반복해도 성립하는거임?
그렇다, 우리가 `핵심 주제 ① : a 와 b 와 𝛾 의 최대공약수가 𝒹로 같다.` 라는 팩트를 갖고 있어도 <br/>
우리는 코틀린 예제로 쓰인 저 코드가 잘 작동하게 되는 이유를 아직 찾지 못했다.<br/>
<br/>
<img 
src="https://postfiles.pstatic.net/MjAyMDA2MjZfMTg2/MDAxNTkzMTYzMTAxNzEz.2ZOU95zPr-Yf7OWs9Iy_qCnvEhVKm2dXLkhaBXATNtUg.8ZPKSf1bE8wpKfN1uR3aXVzZv9YIfl6q2aB3cKgeh84g.GIF.c_blub/48C5FAA5-5FDB-421A-95EA-331A34587FA5.gif?type=w966" width="200" height="200"/>
<br/>
<br/>
코드를 다시 한번 살펴보자
```Kotlin

fun Gcd(a:Int, b:Int):Int {
    var r = a % b
    if (r == 0)
       return b
    else
       return Gcd(b, r)
}
{ ... }
```
Gcd() 는 나머지 𝛾 이 0이 될 때 모든 연산을 끝내게 된다.<br/>
다시 말하면 𝛾 은 유한한 횟수 안에 언젠가 0 된다는 것이다.<br/> 
언젠가는 나머지가 0이 된다라는걸 확신하는 듯한 저 표정이 거만하기 짝이 없다. 저게 블러핑인지 아닌지 한번 확인해보자. <br/>
<br/>
<br/>
`a / b 의 나머지가 𝛾` 이듯, `b / 𝛾 의 나머지가 𝛾´` 라고 말해보자.<br/>
`핵심 주제 ① = 𝒹 는 a와 b 와 𝛾의 최대공약수임` 에 따라서 `gcd(a, b) = gcd(b, 𝛾)` 이듯 `gcd(b, 𝛾) 은 gcd(𝛾, 𝛾´)` 이다.<br/>
<br/>
..어 왜?
<br/>
<br/>
두 정수 a 와 b 를 다시 한번 살펴보자. (a > b), a 와 b 의 최대공약수를 𝒹 라고 할 때 <br/>
>a = q * b + 𝛾<br/>
>gcd(a, b) = gcd(b, 𝛾) <br/>
> a 와 b 의 최대공약수 == b 와 𝛾 의 최대공약수<br/>
<br/>

마찬가지로 이번엔 위의 내용과 상관없이 순수하게 두 정수 b 와 r 을 살펴보자. (b > 𝛾) <br/>
>b = q * 𝛾 + 𝛾´<br/>
>gcd(b, 𝛾) = gcd (𝛾, 𝛾´) <br/>
> b 와 𝛾 의 최대공약수 == 𝛾 와 𝛾´의 최대공약수<br/>
<br/>

`핵심 주제 ① = a 와 b 와 𝛾 의 최대공약수가 𝒹로 같다.`에 따라서 <br/>
- gcd(a,b) == gcd(b,𝛾) 인데
- gcd(b,𝛾) == gcd(𝛾, 𝛾´) 이니
- gcd(a,b) == gcd(𝛾, 𝛾´) 이다.
<br/>

오, 그렇다면 `𝛾´ 과 𝛾´´` 사이에도 `최대공약수는 𝒹` 이고 `𝛾´´ 과 𝛾´´´` 에도 `최대공약수는 𝒹` 이고 `𝛾´´´ 과 𝛾´´´´` 에도 `𝒹` 이고 `{ ... }` 에도 `𝒹`  <br/>
<br/>
<br/>
무한한 나머지와 그 나머지의 최대공약수는 언제나 a 와 b 의 최대공약수와 같다는 건 알겠지만, 혹시 `𝛾´´´´´´{...}`가 0이 안되면 어떻게 될까?? <br/>
<br/>
`𝛾´´´´´´{...}` 를 이제부터 `crazy_𝛾`이라고 불러보자.<br/>
나머지를 계속하다보면 언젠가는 우린 `crazy_𝛾`를 만나게 될텐데, 그때의 식은 다음과 같을 것이다.<br/>

> b > 𝛾 > 𝛾' > 𝛾'' > 𝛾''' ... crazy_r != 0 <br/>
<br/>
<br/>

우리는 기억해내야 한다, `b` 와 `𝛾` 도, 그 어떠한 `crazy_𝛾` 들도 모두 `정수` 라는 것을.<br/>
즉, `crazy_𝛾` 이 정수고, 0이 아니라면 `less_crazy_𝛾`과 `crazy_𝛾`로 나눠서 `more_crazy_𝛾´`라는 정수를 만들 수 있으니<br/>
<br/>

> b > 𝛾 > 𝛾' > 𝛾'' > 𝛾''' ... > less_crazy_𝛾 > crazy_𝛾 > more_crazy_𝛾 > more_crazy_𝛾2 { ... } <br/>
<br/>

가 성립함을 알 수 있고, 여기서 항상 `crazy_𝛾`은 `crazy_𝛾 > more_crazy_𝛾`를 성립하게 된다. <br/>
왜냐하면 `more_crazy_𝛾`는 `crazy_𝛾`의 나머지이니까.<br/>
<br/>
정수가 언제나 앞의 숫자보다 작아진다면, 언젠가는 0에 도달하게 된다. 왜냐고? 그것이 정수이니까 (끄덕) <br/>

> a > b 일 때, a 와 b 가 정수라면 a 와 b 차이의 최솟값은 1<br/>
> a > b > b' 는 최소한 1씩 줄어드는 정수이며, 이게 계속해서 반복된다면 언젠가는 0에 도달하게 된다. 

따라서 `핵심주제 ② = crazy_𝛾은 언젠가는 0이 될 수 밖에 없다` !!<br/>
<br/>
<img 
src="https://blog.kakaocdn.net/dn/b7Rey8/btqExZC771a/cZofK59sF1KN00Exlz3sWK/img.gif" width="200" height="200"/>
<br/>
<br/>
<br/>
마지막으로 코드를 다시 한번 살펴보면
```Kotlin

fun Gcd(a:Int, b:Int):Int {
    var r = a % b
    if (r == 0)
       return b
    else
       return Gcd(b, r)
}
{ ... }
```
<br/>

`var r` 은 재귀함수로 돌아가며 계속해서 `𝛾`, `𝛾´`, `𝛾´´`, `𝛾´´´` {...} `crazy_𝛾` 이 된다 하더라도 <br/>
`핵심주제 ② = crazy_𝛾은 언젠가는 0이 될 수 밖에 없다`에 의해서 언젠가는 0이 된다는 걸 할 수 있다.<br/>
그렇기 때문에, 위의 코드가 `무한히 돌지 않고 유한한 횟수 내에서` 나머지가 0인 순간을 찾을 수 있는 것이다.

---

### 결론
유클리드 호제법을 통해 우리는 다음과 같이
- `핵심주제 ① : a 와 b 와 𝛾 의 최대공약수가 𝒹로 같다.`
- `핵심주제 ② : crazy_𝛾은 언젠가는 0이 될 수 밖에 없다`<br/>

가 성립함을 알 수 있었고, 이에 따라 Gcd(최대공약수)를 구하는, 소위 나머지 알고리즘라는 것이 성립함을 알 수 있었다. <br/>
<br/>

즉 정수 `a`, `b`, `𝛾` 이 있을 때<br/>

```Kotlin
fun Gcd(a:Int, b:Int):Int {
    var r = a % b
    if (r == 0)
       return b
    else
       return Gcd(b, r)
}
```

와 같이 `a` 와 `b` 를 나눈 나머지 `𝛾`가 0이 될 때 까지
- `a = b`
- `b = r` <br/>
을 반복하다보면 언젠가 최대공약수가 나온다는 것을 알게되었다.<br/>
<br/>
<br/>

*Gcd 문제 푸는데 이걸 다 알아야 하냐고?* <br/>

<img 
src="https://postfiles.pstatic.net/MjAyMDA2MjZfMTg2/MDAxNTkzMTYzMTAxNzEz.2ZOU95zPr-Yf7OWs9Iy_qCnvEhVKm2dXLkhaBXATNtUg.8ZPKSf1bE8wpKfN1uR3aXVzZv9YIfl6q2aB3cKgeh84g.GIF.c_blub/48C5FAA5-5FDB-421A-95EA-331A34587FA5.gif?type=w966" width="200" height="200"/>
<img 
src="https://storage.googleapis.com/jjalbot-jjals/2018/12/rylg064feE/20171212_5a2ea716c5d24.gif" width="200" height="200"/>
<br/>

> 출처 <br/>
> brain from 감자 4호 <br/>
> // 알고리즘 공부하면서 알아본 내용입니다, 오류 • 오타 등 알려주시면 정말 감사하겠습니다 :)
