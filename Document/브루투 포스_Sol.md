## 브루트 포스 (Brute Force)

### ◾ 개념
완전탐색 알고리즘 이라고도 한다. 모든 경우의 수를 일일이 다 세보는거다. 예를 들어, 4자리의 암호로 구성된 자물쇠를 풀려고 시도한다고 생각해보자. 이 자물쇠가 고장난 것이 아니라면, 반드시 해결할 수 있는 가장 확실한 방법은 0000 ~ 9999까지 모두 시도해보는 것이다. 그만큼 무식하지만 가장 정확하고 강력한 방법이라고 해서 브루트 포스라는 이름이 붙었다고 한다.

</br>

### ◾ 특징
위에서 언급했듯이 무식해서 시간이 가장 오래 걸리는 방법이지만, 경우의 수를 빼먹지 않는 이상 가장 정확한 해답을 얻을 수 있는 방법이라는 특징이 있다.

</br>

### ◾ 시간복잡도
주로 O(N!)의 시간복잡도가 형성된다. 왜 N! 이냐면 N!은 N부터 1씩 감소하여 1까지 모두 곱하는 경우의 수인데, N명의 사람을 줄세우기를 생각하면 이해가 빠르다. 3명의 사람을 일렬로 줄 세우는 모든 경우의 수를 생각해보자. 3명 중 1명을 맨 앞에 픽스시키고 2번째 자리에는 2명 중 1명이 올 수 있다. 그래서 2가지 경우의 수가 생긴다. 나머지 1자리는 자동적으로 2번째 줄에 서지 못한 사람이 오므로 1가지 경우의 수이다. 그렇게 가장 앞에 서는 사람은 3명 모두 한 번씩 가능하므로 2명이 순서대로 줄 서는 경우의 수는 3세트가 만들어진다. 2x1의 경우의 수가 3번 발생하므로 3x2x1 해서 3!이다. 모든 알고리즘 중에 시간복잡도가 가장 높다. 모든 경우의 수를 일일이 세는 것보다 더 오래 걸릴 수 있는 방법이 없으니까.

</br>


### ◾ 완전 탐색 방법 (🙂종류에 대해서 미리 간단하게 살펴보는 정도로!)
**① Brute Force 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법**  
이 방법은 반복 / 조건문을 통해 가능한 모든 방법을 단순히 찾는 경우를 의미한다. 위에서 예를 들어본 4자리 암호로 구성된 자물쇠를 푸는 로직이다.
```Kotlin

fun main() {
    
var password = (0..9999).random()

for (i in 0..9999) {
    
    var search = 0
    
	if (i == password) {
		println(search)
		break
	} else {
		search++
	}
}
}
```
</br>

**② 순열(Permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법**  
순서대로 뽑아서 줄을 세우는 걸 순열이라고 한다. 순열은 임의의 수열이 있을 때, 그것을 다른 순서로 연산하는 방법을 의미한다.
즉, 순서가 중요함! 만약, 수열에서 숫자 [1, 2, 3]이 있다면, 이것을 [1, 2, 3]으로 보는 순서와 [3, 2, 1]로 보는 순서가 차이가 있음이 중요한 경우를 의미한다.

</br>

**③ 재귀 호출**  
재귀는 말 그대로 자기 자신을 호출한다는 의미이다. 다음은 팩토리얼 함수를 재귀함수로 표현해 본 샘플코드이다. 재귀 함수를 활용한다면 자기 자신을 호출함으로써 다음 숫자를 선택할 수 있도록 이동시켜 <b>전체 코드를 매우 짧게 줄일 수 있다.</b>

```Kotlin
	fun factorial (n: Int, res: Int): Int {
		return if (n <= 0) {
			res
		} else {
			1 + factorial (n-1, n*res)
		}
	}
```

> **브루트 포스에서의 재귀와 DP(Dynamic Programming)의 차이점** </br>
> DP에서 사용하는 재귀함수는 동일한 작은 문제들의 해를 반복적으로 이용하여 큰 문제를 해결하는데 중점이 있고, 브루트 포스에서의 재귀는 그냥 단순히 경우의 수 검증함수를 계속 호출하면서 해를 구하는데 중점이 있다는 차이점이 있다.

</br>

**④ 비트마스크 - 2진수 표현 기법을 활용하는 방법**  
비트(bit) 연산을 통해서 부분 집합을 표현하는 방법을 의미한다.

</br>

비트 연산이란 다음과 같은 것들이 있다.

</br>

And 연산(&) : 둘 다 1이면 1
</br>
OR 연산(|) : 둘 중 1개만 1이면 1
</br>
NOT 연산(~) : 1이면 0, 0이면 1
</br>
XOR 연산(^) : 둘의 관계가 다르면 1, 같으면 0
</br>
Shift 연산(<<, >>) : A << B라고 한다면 A를 좌측으로 B 비트만큼 미는 것이다.
</br>

![퍼가요](https://user-images.githubusercontent.com/75516061/136593534-1340bc55-aa5d-4ffe-a867-1c00f8f97e2c.JPG)
</br>
선택하는 경우를 1, 선택하지 않는 경우를 0으로 보고, 비트 연산자를 통해 각 경우를 표현한다. 
</br>
비트마스크란 단순히 완전탐색을 하는 방법 중에서 하나의 방법론일 뿐 모든 경우를 세준다는 것이 핵심이다.

</br>

### 참고
https://ko.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/the-factorial-function
https://hongjw1938.tistory.com/78
https://itandhumanities.tistory.com/27
https://coding-food-court.tistory.com/189
