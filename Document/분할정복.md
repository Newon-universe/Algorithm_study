# 분할정복(Divide and Conquer)    
---   

### 1. 개념     
  
_순환적(recursive)으로 문제를 푸는 하향식(top-down) 접근 방법_  
  
주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 순환적으로 분할하고 분할된 작은 문제들을 해결한 후   
그 해를 결합하여 원래 문제의 해를 구하는 방식  
  
동적 프로그래밍(Dynamic Programming), 탐욕적 (Greedy)와 같이 알고리즘의 설계 기법 중 하나이다.  
  
  
### 2. 특징    
- 분할된 작은 문제는 원래 문제와 성격이 동일하다. → 입력 크기만 작아짐  
- 분할된 문제는 서로 독립적이다. → 순환적 분할 및 결과 결합 가능  
- 결합의 과정에서 보통 재귀를 사용하는 경향이 있다.

### 3. 장단점     
장점 : 문제를 나눔으로써 어려운 문제를 해결할 수 있다는 장점이 있다. 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결하는 데 장점이 있다.  
  
단점 : 일반적으로 재귀 함수를 사용하기 때문에 오버헤드가 발생하며, 스택에 많은 데이터를 저장하므로 스택 오버플로우가 발생하거나  
ﾠﾠﾠﾠﾠ과도한 메모리 사용을 하게 된다는 단점이 있다.     
     
 <br></br>     

### 4. 분할정복 알고리즘의 처리과정(문제해결과정-기본로직)     

- Divide : 문제가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.
- Conquer : Divide 한 문제가 여전히 분할이 가능하면 다시 Divide 를 수행한다. 그렇지 않다면 문제를 해결한다.
- Combine : Conquer 한 문제들을 통합하여 원래의 답을 얻는다.

 <br></br>     
          
### 5. 시간복잡도     



 <br></br>

### 6. 분할정복 방법이 적용된 병합 정렬(Merge sort), 퀵 정렬(Quick sort)에서의 분할 과정   
  
#### 병합정렬
![](https://gmlwjd9405.github.io/images/algorithm-merge-sort/merge-sort-concepts.png)  

배열에 27, 10, 12, 20, 25, 13, 15, 22이 저장되어 있다고 가정하고 자료를 병합정렬을 통해 오름차순으로 정렬을 목표로 한다.  
  
1. 2개의 리스트의 값들을 처음부터 하나씩 비교하여 두 개의 리스트의 값 중에서 더 작은 값을 새로운 리스트(sorted)로 옮긴다.
2. 둘 중에서 하나가 끝날 때까지 이 과정을 되풀이한다.
3. 만약 둘 중에서 하나의 리스트가 먼저 끝나게 되면 나머지 리스트의 값들을 전부 새로운 리스트(sorted)로 복사한다.
4. 새로운 리스트(sorted)를 원래의 리스트(list)로 옮긴다.

```kotlin
var sorted:Array<IntArray> = arrayOf() // 추가적인 공간이 필요

// i: 정렬된 왼쪽 리스트에 대한 인덱스
// j: 정렬된 오른쪽 리스트에 대한 인덱스
// k: 정렬될 리스트에 대한 인덱스
/* 2개의 인접한 배열 list[left...mid]와 list[mid+1...right]의 합병 과정 */
/* (실제로 숫자들이 정렬되는 과정) */

fun merge(var list:IntArray, var left:Int, var mid:Int, var right:Int) {
  var l
  var i = left
  var j = mid+1
  var k = left

  /* 분할 정렬된 list의 합병 */
  while(i <= mid && j <= right){
    if(list[i]<=list[j])
      sorted[k++] = list[i++];
    else
      sorted[k++] = list[j++];
  }

  // 남아 있는 값들을 일괄 복사
  if(i > mid){
    for(l in j..right)
      sorted[k++] = list[l];
  }
  // 남아 있는 값들을 일괄 복사
  else{
    for(l in i..mid)
      sorted[k++] = list[l];
  }

  // 배열 sorted[](임시 배열)의 리스트를 배열 list[]로 재복사
  for(l in left..right){
    list[l] = sorted[l];
  }
}

// 합병 정렬
fun merge_sort(var list:IntArray, var left:Int, var right:Int){
  var mid: Int;

  if(left < right){
    mid = (left+right)/2 // 중간 위치를 계산하여 리스트를 균등 분할 -분할(Divide)
    merge_sort(list, left, mid); // 앞쪽 부분 리스트 정렬 -정복(Conquer)
    merge_sort(list, mid+1, right); // 뒤쪽 부분 리스트 정렬 -정복(Conquer)
    merge(list, left, mid, right); // 정렬된 2개의 부분 배열을 합병하는 과정 -결합(Combine)
  }
}

fun main(){
  var i;
  var list: IntArray = {21, 10, 12, 20, 25, 13, 15, 22};

  // 합병 정렬 수행(left: 배열의 시작 = 0, right: 배열의 끝 = 7)
  merge_sort(list, 0, n-1);

  // 정렬 결과 출력
  for(i in 0..list.size - 1){
    printf("%d\n", list[i]);
  }
}
```
 <br></br>
     
#### 퀵 정렬
![퀵 정렬 (Quick Sort)](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png)  

배열에 무작위로 저장된 1 ~ 9 까지의 수를 퀵 정렬을 통해 오름차순으로 정렬을 목표로 한다.  

1. 리스트 안에 있는 한 요소(피벗)을 선택한다.  
2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.  
3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.  
4. 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.  
5. 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.  
6. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.  
7. 리스트의 크기가 0이나 1이 될 때까지 반복한다.  
  
```Kotlin
fun Qsort(list: List<Int>): List<Int> {
    if (list.size < 2) {
        return list
    }

    val pivot = list[list.size / 2]
    val left = list.filter { it < pivot }
    val right = list.filter { it > pivot }

    return qsort(left) + listOf(pivot) + qsort(right)
}
```
     
### 7. 동적 계획법(Dynamic Programming)과 분할정복법(Divide and Conquer) 비교
동적 계획법과 분할 정복의 가장 큰 차이점은 계산 결과의 재활용이다. (부분 문제를 각각 독립적으로 나눠지지 않음)  
동적 계획법의 경우 두 번 이상 계산되는 중복되는 부분 문제(overlapping subproblems)의 계산 결과를 캐시에 저장함(재활용)으로써   
여러번 계산되는 것을 막아 속도 향상을 꾀할 수 있다.  
이때, 한번 계산된 결과같은 캐시에 저장하는 최적화 기법을 메모이제이션(momoization)이라고 한다.  

 <br></br>


---  
### 참고     
[분할 정복(Divide and Conquer)](https://bestinu.tistory.com/14)  
[알고리즘-분할정복-방법-이진-탐색-퀵-정렬-알고리즘](https://atoz-develop.tistory.com/entry/알고리즘-분할정복-방법-이진-탐색-퀵-정렬-알고리즘)  
[알고리즘-Divide-and-Conquer-분할정복](https://janghw.tistory.com/entry/알고리즘-Divide-and-Conquer-분할정복)
[\[알고리즘\] 합병 정렬(merge sort)이란](https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html)  
[퀵 정렬 (Quick Sort)](https://week-year.tistory.com/201)  
[코틀린으로 퀵소트 구현하기 (QuickSort with Kotlin) ](https://zion830.tistory.com/126)
