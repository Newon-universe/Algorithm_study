# WEEK 3 : 부르트포스 "Brute Force"

### **◾ 개념**

문제를 해결하기 위해서, 가능한 모든 경우에 대해 모두 직접 해 보는 방법. 무식하게 푸는 법!!

선형 구조를 전체적으로 탐색하는 **순차 탐색**, 비선형 구조를 전체적으로 탐색하는 **깊이 우선 탐색(DFS, Depth First Search)**과 **너비 우선 탐색(BFS, breadth first search)**이 가장 기본적인 도구


### **◾ 특징**

모든 영역을 전체 탐색하는 방법 → 답을 못 구하는 경우는 없지만 입력/출력 제한이 중요하게 작용

브루트 포스 방식으로는 그만큼 만들기가 비교적 쉬운 편, 다른 알고리즘을 생각하는 출발점

시간 측면에서 매우 비효율적


### **◾ 시간복잡도**

가능한 답의 수에 비례함 ⇒ 대부분 O(경우의 수 * 방법 1가지의 소요시간)</p>

### **◾ 완전 탐색에 사용되는 알고리즘 기법들**

완전탐색의 많은 종류의 문제들은 특정 조건을 만족하는 요소를 찾는 것. </br>
전형적으로 순열(permutation), 조합(combination), 그리고 부분 집합(subsets)과 같은 조합적 문제들 (Combinatorial Problems) 과 연관됨 </br>


**① Brute Force 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법**

어느 기법을 사용하지 않고 단순히 for문과 if문 등으로 모든 case들을 만들어 답을 구하는 방법</br>

아주 기초적인 문제에서 주로 이용되거나, 전체 풀이의 일부분으로 이용</p>

**② 순열(Permutation)** 

: 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것. 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있음

서로 다른 N개를 일렬로 나열하는 순열의 경우의 수는 N!</br>

**n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법 : nPr = n x (n-1) x (n-2) x ... x (n-r+1)** 

```java
재귀 호출을 통한 순열 생성
void pick(int n, Stack<Integer> picked, int r) {
  if(r == 0) {                         //더이상 쪼개지지 않는 기저사례
    printPicked(picked); 
		return;
  }
  int smallest = picked.isEmpty() ? 0 : picked.peek() + 1;
  for(int next = 0; next < n; next++) {
    picked.push(next);                  //한 조각 자신이 수행
    pick(n, picked, r - 1);             //나머지 조각 재귀호출
    picked.pop();
  }
}
```
</p>

**③ 재귀 호출** 

재귀 함수(자기 자신을 호출하는 함수)를 통해서 조건을 만족하는 경우들을 찾아가는 방식. 반복적인 일을 해야 하는 코드를 깔끔하고 유연하게 짤 수 있다

비트마스크와 마찬가지로 주로 각 원소가 포함되거나, 포함되지 않는 두 가지 선택을 가질 때 이용된다.

```java
반환값 solve(필요한 자료구조, 데이터들..) {
  if(기저 사례1) ... return ...;
  if(기저 사례2) ... return 반환값;
  반환타입 ret =0;            //필요한 변수 선언 및 계산
  ...
  for(다음에 올 수 있는 경우의 수들) {
    if(가능한 경우) {
      현재 한조각 수행
      ret =현재 한조각 수행 + solve(나머지 조각);
    }
  return ret;
}
```

> 브루트 포스에서의 재귀와 DP의 차이점
> - DP는 작은 문제가 큰 문제와 동일한 구조를 가져, 큰 문제의 답을 구할 시에 작은 문제의 결과를 기억한 뒤 그대로 사용하여 수행 속도를 빠르게 한다.</br>

> - 그에 반해 완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다. </p>


**④ 비트마스크 Bitmask - 2진수 표현 기법을 활용하는 방법** 

비트마스크 : 비트 연산을 통해 부분 집합을 표현하는 방법</br>

비트 연산자 사용으로 간결한 코드 (and-&, or-|, not-~, shift(왼쪽,오른쪽으로 원하는 만큼 움직이고 움직인 후 빈자리는 0으로 채워짐)-<</>>)

- S에 i를 추가 : S |= (1 << i)

- S에서 i를 제거 : S &= ~(1 << i)

- S에 i가 있는지 검사 : S & (1 << i)

- 전체 집합은 (1<<N) - 1 로, 공집합은 0으로 나타낼 수 있다
</p>

### **참고**

[https://rebro.kr/59](https://rebro.kr/59)

[https://rebro.kr/63](https://rebro.kr/63)
