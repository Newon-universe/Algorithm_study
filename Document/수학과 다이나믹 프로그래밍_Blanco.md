## 수학과 다이나믹 프로그래밍

### 소수
#### ◾ 개념
소수(Prime Number)는 약수로 1과 자기 자신만을 가지는 정수이다. 정수론의 기본 정리에 의해 모든 자연수는 단 하나의 소수들의 곱으로 표현된다.
#### ◾ 기본 로직

```kotlin
 // 풀이 코드
/* 시간복잡도 : O(N) */
fun main() {
    val br = System.`in`.bufferedReader()
    val list2 = BooleanArray(102, {false})
    
    for (i in 1 until list2.size) {
        for (j in i-1 downTo 2) {      //  자기 자신과 1을 제외한 수로 나눔.
            if (i % j == 0) {             //  나머지가 0이라는 것은 자기 자신과 1을 제외한 수로 나눠진다는 뜻으로 소수가 아님.
                list2[i] = true          
            }
        }
    }

    for (i in 2 until list2.size) {
        if (list2[i] == false) {           //  소수만 출력 
            print(i)
        }
    }
}

/* 시간복잡도 : O(N^(1/2)) */
fun main() {
    val br = System.`in`.bufferedReader()
    val list2 = BooleanArray(102, {false})
    
    for (i in 1 until list2.size) {
        for (j in sqrt(A.toDouble()).toInt() downTo 2) {      //  제곱근까지만 확인
            if (i % j == 0) {             //  나머지가 0이라는 것은 자기 자신과 1을 제외한 수로 나눠진다는 뜻으로 소수가 아님.
                list2[i] = true          
            }
        }
    }

    for (i in 2 until list2.size) {
        if (list2[i] == false) {           //  소수만 출력 
            print(i)
        }
    }
}
```

#### ◾ 에라토스테네스의 체
소수를 구하는 방법 중에서 시간이 덜 걸리고 빠르게 찾을 수 있다. 
에라토스테네스의 체는 가장 먼저 소수를 판별할 범위만큼 배열을 할당하여, 해당하는 값을 넣어주고, 이후에 하나씩 지워나가는 방법을 이용한다.

1. 배열을 생성하여 초기화한다.
2. 2부터 시작해서 특정 수의 배수에 해당하는 수를 모두 지운다.(지울 때 자기자신은 지우지 않고, 이미 지워진 수는 건너뛴다.)
3. 2부터 시작하여 남아있는 수를 모두 출력한다.

```kotlin
 // 풀이 코드
 /* 시간복잡도 : O(N log(log N)) */
 fun main() {
    val br = System.`in`.bufferedReader()
    val prime = BooleanArray(1001, {true}) //1)
    prime[0] = false
    prime[1] = false
    
   for (i in 2..1000) {
       if (prime[i]) {
          for (j in 2 * i..1000 step i) {
              prime[j] = false
              // 2) 소수의 배수들을 싹다 false 처리
          }
    }
    
    for (i in 2..1000) {
        if(prime[i] == true) print("${i}")
    }
}
```

#### ◾ 시간 복잡도
기본 로직과 에라토스테네스의 체 각각의 시간복잡도에 대해 서술

기본 로직 시간복잡도 : O(N) => O(N^(1/2))

Why? 
모든의 경우의 수를 다 돌며 약수 여부를 확인하기 때문. 그런데 O(N^(1/2))로 계산할 수 있다. 왜냐하면 N의 약수는 무조건 sqrt(N)의 범위에 존재한다.
만약 N이 12라 할때, 12의 제곱근은 약 3.46이다. 12의 약수는 1, 2, 3, 4, 6, 12 이다. 여기서 1과 12를 제외했을 때 이는 2 * 6, 3 * 4, 4 * 3, 6 * 2의 결과이다.
이들의 관계는 몫이 커지면 나누는 값이 작아지거나 나누는 값이 커지만 몫이 작아지는 반비례 관계이다. 

결국 N의 절반(제곱근)까지 향하게 되면 이후 몫과 나누는 값이 반대로 바뀌게만 되는 상황이다.
따라서 N의 제곱근까지 나누어 떨어지는지 여부를 조사하면 더 빠르게 소수판별을 할 수 있다.
그러므로 특정한 숫자의 제곱근까지만 약수의 여부를 검증하면된다. 

에라토스테네스의 체 : O(N log(log N))
</br>

### 다이나믹 프로그래밍
#### ◾ 개념
큰 문제를 작은문제로 나누어 푸는 문제를 일컫는 방법. 쉽게 말해 답을 재활용하는 기법이다. 

Q) 그럼 왜 동적 계획법인가요?

A) 어떤 부분에서 동적으로 프로그래밍이 이루어지는지는 몰라도 된다. 그저 창조한 사람도 이름이 멋있어서 부여했다고 함.

#### ◾ 조건  
**1. 첫번째 조건**  
> 부분 반복 문제(Overlapping Subproblem) 

동적 계획법의 등장은 피보나치 수열에서 시작되었다고 하는데,
피보나치 수열은 대표적인 재귀 함수로 아래와 같이 표현 할 수 있다.

fib(1) = 1; fib(2) = 1;
fib(n) = fib(n-1) + fib(n-2);

만약 fibo(7)을 구하는 과정을 도식화 해보면 아래 이진 트리와 같은데

![캡처](https://user-images.githubusercontent.com/42407740/135694358-7b57ac5f-f3d3-4c99-875f-cbb96b91c8c2.JPG)

7번째 값을 구하기 위해 25번의 함수 호출이 진행된다.
이 과정에서 fib(5), fib(4), fib(3) 들이 이미 진행했던 연산임에도 재귀되며
반복적으로 연산 하는것을 볼 수 있다.

이러한 반복적인 연산을 부분 반복 문제(Overlapping Subproblem) 라 한다.
이는 어떤 문제가 여러개의 부분 문제(Subproblem)으로 쪼개질 수 있을때 사용하는 용어이다.

이때 부분 문제(Subproblem)란 항상 새로운 부분 문제를 생성해내기 보다는 계속해서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제를 가리킨다.

**2. 두번째 조건**  
> 최적 부분 구조(Optimal Substructure)
최적 부분 구조란, 작은 부분 문제에서 구한 최적의 답으로 합쳐진 큰 문제의 최적의 답을 구할 수 있어야 한다는 것이다.

아래 피보나치 수열의 식에서

fib(n) = fib(n-1) + fib(n-2);
큰 문제의 답인 fib(n)이 최적의 답이 되려면 작은 부분 문제인 fib(n-1)과 fib(n-2)이 최적의 답이어야 한다.
작은 부분 문제의 최적의 답으로 큰 문제의 최적의 답을 구할 수 있는 것이다.

fib(n-1)을 구하기 위해서 다시 fib(n-2) + fib(n-3)이 되고, 이 때 fib(n-2)가 중복이 된다.
그리고 최적 부분 구조를 만족한다면, 문제에 크기에 상관없이 어떤 한 문제의 답은 일정하다.

예를 들어 설명 해보면

fib(7)에서 구한 fib(4)
fib(6)에서 구한 fib(4)
fib(5)에서 구한 fib(4)
fib(4)에서 구한 fib(4)
이 fib(4)의 값들이 항상 같은 값인 것이다.

그렇다면 fib(4)를 반복해서 연산하는 것은 의미가 없다.

이 반복되는 연산 과정을 줄이기 위해서는 어떻게 해야 할까? 메모이제이션을 사용해야한다!

#### ◾ 메모이제이션(Memoization) 이란?
답을 재활용 한다는 의미를 Memoization이라고 하는데, 이는 컴퓨터 용어로 동일한 계산을 한 경우 한번 계산한 결과를 메모리에 저장해 두었다가 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다. 이 기법은 메모리라는 공간적 비용을 투입해 시간적 비용을 줄이는 방식이다. 

#### ◾ 분할 정복 방식과의 차이점
거의 비슷하지만 차이점이있다. "작은 문제가 중복이 일어나는가 안일어나는가"이다. 

분할정복 : 큰 문제를 해결하기 어려워 단지 작은 문제로 나누어 푸는 방법.
동적프로그래밍 : 작은 부분문제들이 반복되는 것(답이 바뀌지 않음)을 이용해 풀어나가는 방법.

DP는 별도의 메모리를 소비하기 때문에 그리디 알고리즘에 비해 시간 복잡도는 크지만 문제를 풀 수 있는 스펙트럼이 넓고 근삿값이 아닌 최적의 값을 얻을 수 있다.

#### ◾ 기본 로직
**1. Top-down**  
> Top down 방식으로 문제를 푸는 방법은 다음과 같다.

1. 문제를 작은 문제로 나눈다.

2. 작은 문제들을 푼다.

3. 작은 문제들의 답으로 전체 문제를 푼다.

4. Top down 방식은 보통 재귀로 구현이 된다.  
```kotlin
 // 풀이 코드
 fun fib(n : int): Int {
     var memo = IntArray(101,{0})
     memo[1] = 1
     memo[2] = 1
     
     if (memo[n] !=0) {
        return memo[n]
     }
     
     memo[n] = fib(n-1) + fib(n-2)
     
     return memo[n]
 }
```

**2. Bottom-up**  
> Bottom-Up 방식으로 문제를 푸는 방법은 다음과 같다.

1. 가장 작은 문제부터 푼다.

2. 문제의 크기를 점점 크게 만들어서 전체문제를 푼다.  
```kotlin
 // 풀이 코드
 fun fib(n : int): Int {
     var memo = IntArray(101,{0})
     memo[1] = 1
     memo[2] = 1
     
     for (i in 3..n) {
        memo[i] = memo[i-1] + memo[i-2]
     }
     return memo[n]
 }
```

</br>

### 참고
[https://jm-park.github.io/algorithm/2018/08/06/Prime-Number(%EC%86%8C%EC%88%98)-%ED%8C%90%EB%B3%84%EB%B2%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html]
[https://velog.io/@gillog/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming]
[https://hanyeop.tistory.com/117]
