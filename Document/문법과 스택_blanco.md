## 문법과 스택

### 입출력 받는 방법

Java에는 Scanner.next()와 System.out.println()의 기본적인 입출력 함수들이 존재한다. 
  마찬가지로, Kotlin에는 readLine()과 println()의 기본적인 입출력 함수들이 존재한다.

  위 함수들은 사용이 간편한 대신, 느린 입출력(slow I/O)에 해당한다.
  Why? 우리는 보통 (Java에서)이렇게 스캐너를 정의하여 사용한다.

  Scanner sc = new Scanner(System.in);
  여기에서 System.in은 InputStream타입의 정적 필드이다.

  한 줄로 요약하자면, Scanner는 수많은 자바 정규식을 검사하는 과정에서 심각한 비효율이 발생하고
  println이나 readLine도 비슷한 맥락에서, 내부적으로 많은 공정이 이루어지므로 처리 속도가 굉장히 느리다.

  그렇다면, 빠른 입출력에는 어떤 것들이 있을까? 바로 BufferedReader와 BufferedWriter이다.
  BufferedReader가 빠른 이유는 즉, Scanner와 다른 점은 다음과 같다.

  1. 정규식을 확인하지 않고 바로 처리한다.

  2. 입력을 그때그때 처리하는 Scanner와 달리, 버퍼를 통해 처리 시점을 개발자가 직접 지정해줄 수 있다.

### 사칙연산
 
코틀린의 사칙연산에는 덧셈(+), 뺄셈(-), 나눗셈(/), 곱셈(*) 그리고 나머지 연산(MOD)(%)이 있습니다.
 
 ex)
 print(a+b)
 print(a-b)
 print(a/b)
 print(a*b)
 print(a%b)

### if 문
java의 if문 사용과 동일하다. if 조건식에는 비교 연산자(==, !=, <, >, >=, <=)와 논리 연산자(&&, ||, !)를 사용한 조건식만 사용 가능하며, 조건식의 결과는 Boolean 타입인 true와 false로 나  타난다.
 
 ex)
 if (조건) {
  print("조건문에 해당")
 } else if(조건) {
  print("다른 조건문에 해당")	
 } else{
  print("나머지")
 }


### for 문과 while 문
kotlin에서 for문과 while문은 java와 동일
  for문 : in연산자와 downto,step을 통해서 증감을 제어하고 루프를 시작한다.
  상행 : i in 0 .. 5(0부터 5까지), 
  하행 : downto연산자 사용
  step연산자를 통해서 1씩이 아닌 2,3씩 증가,감소 가능
 
 ex)
 for (조건) {
  
 }
 while문 / do-while문 : while문은 루프를 시작하기 전에 조건을 검사하고 do-while문은 일단 한번 루프를 실행한 후 조건을 검사한다는 것이 둘의 차이점이다.
  보통 무한루프를 돌릴 때 많이 사용한다(조건문에 true를 사용하고 if문과 break를 통해서 제어한다.)
  
 ex)
 while (조건) {  
 
 }

### 1차원 배열  
- 배열은 크기를 미리 선언해서 공간의 추가 및 삭제가 불가능한 자료형이다. 같은 타입의 데이터를 묶어서 관리하기에 용이하다.
 
 -배열의 선언
 ex) 
 var array = Array<Int>(5,{0}) <- 이렇게 선언할 수 있고 <>안에는 타입을 지정할 수 있다. 
 var array = IntArray(5) <- 이렇게도 표현가능하다.
 var array = intArrayOf(0,0,0,0,0) <- arrayOf함수를 사용해서 배열을 직접 만들 수도 있다. 
 
 -배열의 참조
 ex) 
 array[1] <- 이런식으로 배열의 각 index값을 참조 할 수 있다.
 array[2]
 

</br>
</br>

### Stack
#### 개념

- Stack은 LIFO(Last In First Out)의 특징을 가지는 자료 구조이다. 즉, 맨 마지막에 들어온 값이 가장 먼저 나가는 자료 구조이다. 
- 데이터 한 쪽 에서만 자료를 넣고 뺄 수 있다.
1. push()
    push() 연산은 스택에 데이터를 push, 즉 삽입하는 연산이다.

    현재 스택의 가장 최근의 들어온 데이터(가장 상단에 위치한 데이터)를 top이 가리키게 된다.
    push 연산을 하게 될 경우 현재 top이 가리키는 데이터 위에 데이터를 추가한 뒤, 추가된 데이터를 top이 가리킨다.

2. pop() 
   pop() 연산은 스택에 데이터를 pop, 즉 꺼내는 연산이다.

   현재 스택에서 top이 가리키고 있는 데이터를 꺼낸 후, 현재 스택에서 최상단에 위치한 데이터를 top이 가리키게 된다.
   만일 꺼낼 데이터가 없을 경우에는 pop 연산이 실행되지 않는다.

3. peek()
   peek() 연산은 현재 top이 가리키고 있는 데이터를 확인하는 연산이다.
   이때 pop()과의 다른 점이라면, pop연산은 데이터를 stack에서 꺼내서 읽는다면 peek 연산은 데이터를 꺼내지 않고 값만 읽는 것이다.

4. isEmpty()
   isEmpty() 연산은 현재 stack이 비어있는지 확인하는 연산이다.
   stack이 비어있다면 true, 비어있지 않다면 false를 반환한다.

※ Kotlin에서는 java와 달리 stack이 구현되어 있는 라이브러리가 존재하지 않는다. 그래서 2가지의 방법이 있는데 MutableList를 stack처럼 사용하거나 java의 stack 라이브러리를 사용하는 것이다.
  
#### 시간복잡도
- 삽입 연산의 경우, 데이터의 개수에 상관없이 맨 위에 데이터를 삽입하는 연산만 진행하므로 O(1)이다.
  삭제 연산도 삽입연산과 마찬가지로 맨 위에 있는 데이터를 꺼내는 연산만 진행하므로 O(1)이다.
  검색 연산의 경우는 현재 stack에 존재하는 모든 데이터를 찾는 것이므로 데이터가 n개라면 n개를 순회해야 하기 때문에 O(n)이다.
  ※ O(1)이라는 표현에서 1은 constant 즉, 상수 시간을 말한다.

#### 장점

- 데이터의 삽입과 삭제가 빠르다.
- 구현이 쉽다.

#### 단점

- 맨 위의 원소만 접근 가능하다.
- 탐색을 하려면 원소를 하나하나 꺼내서 옮겨가면서 해야한다.

#### 결론

- 스택에 적합한 자료구조일 경우에 사용  
  코딩테스트에서 괄호관련 문제에서 많이 사용된다.

##### 참고
https://meoru-tech.tistory.com/57
https://velog.io/@hanif/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%8A%A4%ED%83%9D
