## 트리

### 개념
트리(Tree)란 계층적인 구조를 표현하기 위해 일상적으로 사용하는 구조이다.

### 트리 관련 용어
![](https://user-images.githubusercontent.com/62331803/102054701-1ca5a400-3e2d-11eb-9851-eba53a2cb006.png)
#### 노드의 명칭
- **루트(root) 노드** : 맨 위에 위치한 노드
- **리프(leaf) 노드** : 자식이 없는 노드

#### 기타 용어
- **서브트리(sub-tree)** : 트리에서 어떤 한 노드와 그 노드의 자손들로 이루어진 트리를 부트리(sub-tree)라고 부른다. 
- **간선/엣지/링크/브랜치** : 노드와 노드를 연결하는 선
- **레벨(level)** : 0이나 1부터 시작
-  **높이(height)** : 트리에 존재하는 서로 다른 레벨의 총 개수
- **깊이(depth)** : 루트노드부터 현재노드까지 오는 데 거치는 간선의 개수

#### 노드간의 관계
- **부모-자식(parent-child) 관계** : 루트노드를 제외한 모든 노드는 하나의 부모를 갖는다. 간선으로 이어진 2개의 노드 중, 위의 노드가 부모이고 아래 노드가 자식ㅇ이 된다.
- **형제(sibling)** 관계 : 부모 노드가 같은 노드들은 형제 관계를 가진다.
- **조상-자손(ancestor-descendant) 관계** : 부모-자식 관계를 확장한 관계이다.

### 트리와 그래프의 차이
1.  하나의 트리에는 두 개의 정점 사이에 하나의 경로 만 존재하는 반면 그래프는 노드 사이에 단방향 및 양방향 경로를 가질 수 있다.
2.  트리에는 정확하게 하나의 루트 노드가 있으며 모든 자식은 단 하나의 부모 만 가질 수 있다. 반대로 그래프에서 루트 노드의 개념은 없다.
3.  그래프에는 루프와 자체 루프가있을 수 있지만 트리에는 루프와 자체 루프가있을 수 없다.
4.  그래프는 루프와 자체 루프를 가질 수 있기 때문에 더욱 복잡합니다. 대조적으로 나무는 그래프에 비해 단순하다.
5.  트리는 선주문, 순차 및 후행 기술을 사용하여 가로 지릅니다. 다른 한편, 그래프 트래버 설에서는 BFS (Breadth First Search)와 DFS (Depth First Search)를 사용한다.
6.  나무는 n-1 개의 모서리를 가질 수 있습니다. 반대로, 그래프에는 미리 정의 된 수의 에지가 없으며 그래프에 따라 다르다.
7.  트리에는 계층 적 구조가 있지만 그래프에는 네트워크 모델이 있다.

## 이진트리 (Binary Tree)

### 개념
각 노드가 최대 2명의 자식을 가지는 트리이다.
자식 노드는 항상 자신이 부모의 왼쪽자식인지 오른쪽자식인지를 부여받는다.
> - 자식이 한 명일 때도 동일하게 왼쪽/오른쪽에 대한 정보를 부여받는다.
>  - 따라서 두 개의 트리가 같은 key를 가지는 노드를 자식으로 가지고 있다고 해도, 왼쪽/오른쪽 위치가 다를 경우 다른 트리로 취급한다.
  
### 이진트리 분류
#### 완전 이진 트리 (Complete Binary Tree)
![](https://t1.daumcdn.net/cfile/tistory/993E103359F71FBD2B) </br>
위의 트리는 완전 이진 트리로 루트 노드를 시작으로 하여 왼쪽에서부터 오른쪽으로 빠지지 않고 채워져 있는 트리이다. 만약 중간에 노드가 하나라도 빠지면 그것은 완전 이진 트리가 아니다. 예를 들어 위에 트리에서 C노드가 빠진다면 위의 트리는 완전 이진 트리라고 부를 수 없다. 완전 이진 트리는 왼쪽 자식과 오른쪽 자식에 따라 다른 트리라고 보게 된다. 예를 들어 A노드의 왼쪽 자식 노드가 B이고 오른쪽 자식 노드를 C인 완전 이진 트리와 반대로 A노드의 왼쪽 자식 노드가 C이고 오른쪽 자식 노드가 B인 경우에는 서로 다른 완전 이진 트리라고 한다. 이것은 자식이 한 개인 경우에도 동일하다.

#### 포화 이진 트리 (Full Binary Tree)
![](https://t1.daumcdn.net/cfile/tistory/99907A3359F720BF25) </br>
- 포화 이진 트리는 완전 이진 트리처럼 왼쪽에서 오른쪽으로 채워져 있는 노드입니다. 다만 차이점은 리프 노드를 제외하고 모든 노드들의 차수가 2이며, 리프 노드는 자식을 가지지 않는다는 것입니다. 말 그대로 트리가 가득 차 있는 형태를 의미한다.
- 포화 이진 트리에서 높이가 `h`인 경우의 노드의 개수는 $$2^h-1$$ 개 이다.
- 포화 이진 트리와 완전 이진 트리에서 노드가 `N`개인 이진 트리의 높이는 `O(logN)`이 된다. 최악의 경우에는 `N`이 될 수도 있다.

#### 트리간의 관계성
포화 이진 트리는 완전 이진 트리의 개념을 포함하는 개념이다. 모든 완전 이진 트리는 포화 이진 트리가 될 수 없지만, 모든 포화 이진 트리는 완전 이진 트리라고 할 수 있다.

### 트리 표현법
배열 표현법과 링크 표현법에 대해서 작성해주세요.  
필요하다면 코드도 함께 작성해주세요.

## 순회

### 개념
![](https://blog.kakaocdn.net/dn/l4O6k/btqNHZF1hzd/l3yGM8RCyoxi8ZkrvOKzc1/img.png) </br>
이진 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고  있는 데이터를 목적에 맞게 처리하는 것을 의미한다.

### 종류
이진트리를 순회하는 표준적인 방법에는 **전위, 중위, 후의**의 3가지 방법이 있다.

루트와 왼쪽 서브 트리, 오른쪽 서브 트리 중에서 루트를 언제 방문하느냐에 따라 구분된다.  
  

-   루트를 방문하는 작업을 V
-   왼쪽 서브 트리 방문을 L
-   오른쪽 서브트리 방문을 R

-   루트를 서브 트리에 앞서서 먼저 방문하면  **전위 순회**
-   루트를 왼쪽과 오른쪽 서브 트리  중간에 방문하면  **중위 순회**
-   루트를 서브 트리 방문  후에 방문하면  **후위 순회가**  된다.

### 코드
```java
//전위순회 Preorder : Root -> Left -> Right
public  void  preOrder(Node  node)  {
	if(node  !=  null)  {
		System.out.print(node.data +  "  ");
		if(node.left !=  null)  preOrder(node.left);
		if(node.right !=  null)  preOrder(node.right);
	}
}

//중위 순회 Inorder : Left -> Root -> Right
public  void  inOrder(Node  node)  {
	if(node  !=  null)  {
		if(node.left !=  null)  inOrder(node.left);
		System.out.print(node.data +  "  ");
		if(node.right !=  null)  inOrder(node.right);
	}
}

//후위순회 Postorder : Left -> Right -> Root
public  void  postOrder(Node  node)  {
	if(node  !=  null)  {
		if(node.left !=  null)  postOrder(node.left);
		if(node.right !=  null)  postOrder(node.right);
		System.out.print(node.data +  "  ");
	}
}
```

## 그리디 알고리즘

### 개념
**매 선택에서 현재 당장 최적인 답**을 선택해 전체 적합한 결과를 도출하자는 알고리즘 기법이다.

### 사용조건
**1) 탐욕 선택 속성(Greedy Choice Property)**  
이전의 선택이 이후에 영향을 주지 않음을 의미한다.

**2) 최적 부분 구조(Optimal Substructure)**
부분 문제의 최적결과가 전체에도 그대로 적용될 수 있어햐 한다는 것을 의미한다.

### 코드 예시
**Action Selection** 문제
> **N개의 활동이 있고 각 활동에는 시작 시간 및 종료 시간이 있을 때, 한 사람이 최대한 많이 할 수 있는 활동(Activity)의 수**를 구하는 문제이다.
즉, 각각의 활동(Activity)에는 시간이 소요되므로 하나를 선택했다면 그 동안 해당 시간에 다른 Activity를 할 수 없다. 이러한 상황일 때 가장 많은 활동에 참여하려면 어떻게 해야 할까?

![](https://blog.kakaocdn.net/dn/bJESw9/btq1be5fQTS/rFtZxQJ8Ci1QtSla90vKdk/img.png) </br>
위에서 각 활동과 그것들의 시작 / 종료 시간이 설정되어 있는 것을 알 수 있다. 이 문제는 최대한 많은 활동을 해야 하므로 언제 시작하든 전체에서  **가장 종료 시간이 빠른 것부터 선택**해야 한다.

어차피 시작 시간은 종료 시간 이전이므로 고려하지 않는다.

따라서,  **종료 시간을 기준으로 정렬**한 뒤,  **제일 먼저 끝나는 활동을 무조건 선택**하고 끝났을 때,  **바로 다음에 선택할 수 있는 활동**을 찾아 수행하는 방식을 반복하여 해결할 수 있다.

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        // 활동 정보를 List에 저장하고 정렬한다.
        ArrayList<Action> list = new ArrayList<>();
        list.add(new Action("A", 7, 8));
        list.add(new Action("B", 5, 7));
        list.add(new Action("C", 3, 6));
        list.add(new Action("D", 1, 2));
        list.add(new Action("E", 6, 9));
        list.add(new Action("F", 10, 11));
        Collections.sort(list);
        
        // Greedy 알고리즘 수행 후, 결과 출력
        ArrayList<Action> ans = greedy(list);
        for(Action act : ans){
            System.out.print(act.name + ", ");
        }
    }

    // Greedy 알고리즘을 통해 선택된 활동들을 반환한다.
    private static ArrayList<Action> greedy(ArrayList<Action> list){
        int time = 0;
        ArrayList<Action> ans = new ArrayList<>();

        for(Action act : list){
            if(time <= act.startTime){
                time = act.endTime;
                ans.add(act);
            }
        }
        return ans;
    }
}

// 활동 정보를 가진 Class로 Comparable을 구현하여 종료 시간 기준 오름차순으로 정렬함.
class Action implements Comparable<Action>{
    String name;
    int startTime;
    int endTime;
    public Action(String name, int startTime, int endTime){
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    @Override
    public int compareTo(Action a) {
        return this.endTime - a.endTime;
    }

    @Override
    public String toString() {
        return this.name;
    }
}

// 결과
// D, C, A, F, 
```


## 참고

[트리 Tree 2 - 이진 트리의 순회 / 구현](https://minhamina.tistory.com/83?category=837168) </br>
[트리 자료구조의 개념과 구현](https://ahnyezi.github.io/java/javastudy-5-tree/) </br>
[알고리즘-그리디 알고리즘(Greedy Algorithm)](https://hongjw1938.tistory.com/172)
