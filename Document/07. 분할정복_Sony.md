

# 분할정복(Divide and Conquer)    

### 1. 개념     
- 분할정복법은 주어진 문제를 작은 사례로 나누고(Divide) 각각의 작은 문제들을 해결하여 정복 (Conquer)하는 방법이다.

- 분할정복법은 문제의 사례를 2가지 이상의 더 작은 사례로 나누어서 해결한다.

- 하향식(top-down) 접근 방식으로 최상위 사례의 해답은 아래로 내려가면서 작은 사례에 대한 해답을 구함으로써 전체 문제를 해결한다.

#### 분할정복법의 설계전략
1. 문제 사례를 하나 이상의 작은 사례로 분할(Divide)한다.
2. 작은 사례들은 각각 정복(Conquer)한다. 작은 사례가 충분히 작지 않은 이상 재귀를 사용한다.
3. 필요하다면, 작은 사례에 대한 해답을 통합(Combine)하여 원래 사례의 해답을 구한다.

 <br></br>
 
### 2. 특징    
-   분할된 작은 문제는 원래 문제와 성격이 동일하다 -> 입력 크기만 작아짐
-   분할된 문제는 서로 독립적이다(중복 제거 X) -> 순환적 분할 및 결과 결합 가능

분할정복은 Top-down방식으로 재귀 호출의 장단점과 똑같다고 보면 된다.

 <br></br>

### 3. 장단점     
#### 장점
문제를 나눔으로써 어려운 문제를 해결할 수 있다.
그리고 이 방식이 그대로 사용되는 효율적인 알고리즘들도 여러 있으며, 문제를 나누어서 해결한다는 특징상 병렬적으로 문제를 해결하는 데에 있어서 큰 장점이다.

#### 단점
함수를 재귀적으로 호출한다는 점에서 함수 호출로 인한 오버헤드가 발생하며, 스택에 다양한 데이터를 보관하고 있어야 하므로 Stack Overflow가 발생하거나 과도한 메모리 사용을 하게 되는 것이 단점이다.
 <br></br>     

### 4. 분할정복 알고리즘의 처리과정 (문제해결과정-기본로직)     
분할정복의  **핵심 진행방식**은 다음과 같다.

① 분할 : 동일한 타입의 하위 문제로 큰 문제를 분할한다.  
② 정복 : 재귀적으로 하위 문제들을 해결한다.  
③ 병합 : 적절히 해결된 결과를 사용해 큰 문제를 해결한다.


 <br></br>     

### 5. 시간복잡도     
#### Best Case
시간 복잡도 = left 시간 + right 시간 + merge 시간
B(n) = B(n/2) + B(n/2) + n/2 = nlog₂n + n/2  ∈  **θ(nlog₂n)**

#### Worst Case 
시간 복잡도 = left 시간 + right 시간 + merge 시간
W(n) = W(n/2) + W(n/2) + n-1 = nlog₂n - (n - 1)  ∈  **θ(nlog₂n)**
 <br></br>
      
### 6. 분할정복 방법이 적용된 병합 정렬(Merge sort), 퀵 정렬(Quick sort)에서의 분할 과정      
#### 병합정렬(Merge sort)
![](https://blog.kakaocdn.net/dn/bzykxw/btq5YpGGRoa/jcf1LIViMnKoh9xmbOogBK/img.gif)
1.  나누어지는 문제의 개수: 2
2.  분할 후 문제의 크기: N/2
3.  각 문제마다 병합(정복) 단계에서 걸리는 시간: O(N)

k - 1단계에서는 2^(k - 1)번, 2단계에서는 2^2=4번, 1단계에서는 2번, 0단계에서는 1번의 병합을 해야 하는데 각 병합에 걸리는 시간이 해당 문제 크기가 N일때 O(N)이다.  
그러므로 각 단계별로 드는 연산 횟수를 죽 늘어놓았을 때
>0단계: 1 _O(N)  
1단계: 2_ O(N / 2)  
2단계: 4 _O(N / 4)  
m단계: 2^m_ O(N / (2^m)) = O(N)
```java
public class MergeSort{
    public static void main(String[] args){
        int[] arr = new int[100];
        for(int i=0; i < arr.length; i++){
            arr[i] = (int)(Math.random() * 100);
        }
        
        mergeSort(arr, 0, arr.length-1);
        for(int i=0; i < arr.length; i++){
            System.out.print(arr[i] + ", ");
        }
    }
    
    public static void mergeSort(int[] arr, int start, int end){
        if(start == end) return;
        
        int mid = (start+end)/2;
        mergeSort(arr, start, mid);
        mergeSort(arr, mid+1, end);
        
        int[] temp = new int[end-start+1];
        int idx = 0;
        int left = start;
        int right = mid+1;
        while(left <= mid && right <= end){
            temp[idx++] = arr[left] <= arr[right] ? arr[left++] : arr[right++];
        }
        while(left <= mid){
            temp[idx++] = arr[left++];
        }
        while(right <= end){
            temp[idx++] = arr[right++];
        }
        for(int i=start; i <= end; i++){
            arr[i] = temp[i-start];
        }
    }
}
```

#### 퀵 정렬(Quick sort)
![](https://blog.kakaocdn.net/dn/c66pRH/btrfjcSskoZ/kgpEFQtubPXsQXYgXSM2Kk/img.png)
![](https://blog.kakaocdn.net/dn/cyNkUR/btrfjcEVDLb/u9Ts8FKkGXiilZ5HqiwXM0/img.png)
![](https://blog.kakaocdn.net/dn/bqPG5M/btrffOltMU6/T988nYpgCOrqCrEmCkzq01/img.png)
![](https://blog.kakaocdn.net/dn/SgKnB/btrfiGlXzKN/p8Fapf4zkfuWThBMCv5xHK/img.png)
![](https://blog.kakaocdn.net/dn/duH8Pe/btrfheKJ94H/gEfKlZazhpmY1ZnLVSNUB1/img.png)

1. 피벗을 하나 선택한다.
2. 피벗을 기준으로 양쪽에서 피벗보다 큰 값, 혹은 작은 값을 찾는다. 왼쪽에서부터는 피벗보다 큰 값을 찾고, 오른쪽에서부터는 피벗보다 작은 값을 찾는다.
3. 양 방향에서 찾은 두 원소를 교환한다.
4. 왼쪽에서 탐색하는 위치와 오른쪽에서 탐색하는 위치가 엇갈리지 않을 때 까지 2번으로 돌아가 위 과정을 반복한다.
5. 엇갈린 기점을 기준으로 두 개의 부분리스트로 나누어 1번으로 돌아가  **해당 부분리스트의 길이가 1이 아닐 때 까지 1번 과정을** 반복한다. **(Divide : 분할)**
6. 인접한 부분리스트끼리 합친다. **(Conqure : 정복)**
 <br></br>
       
### 7. 동적 계획법(Dynamic Programming)과 분할정복법(Divide and Conquer) 비교
**분할 정복**과  **동적 프로그래밍**은  **주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점**은 같다.

차이점은, 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰며, **동일한 중복이 일어나면 동적 프로그래밍을 쓴다는 것**이다.
또한, 분할정복은 Top-Down만 가능하지만 동적 프로그래밍은 Bottom-up도 가능하다.

 <br></br>

### 8. 참고할만한 그림을 넣어주세요     
![](https://blog.kakaocdn.net/dn/1jaZt/btrd1xZC9sT/BZy2RklFUqqUhS1AuCJxW1/img.png)

 <br></br>



---  
### 참고     
[코드 저장소](https://kimch3617.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5%EB%B2%95-Divide-and-Conquer)</br>
[알고리즘 - 분할정복(Divide & Conquer)](https://hongjw1938.tistory.com/193)</br>
