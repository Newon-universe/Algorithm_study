## 링크드리스트(인접리스트)

### ◾ 개념 및 형태

### ◾ 언어별 선언 및 사용방법(CRUD)

### ◾ 시간복잡도

### ◾ 장점

### ◾ 단점

</br>

## 그래프

### ◾ 개념
노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조
### ◾ 구현방법 1 : 인접 리스트 이용
- 구현방법, 특징, 시간/공간복잡도 등
리스트를 사용하는 방식
간선의 개수만큼인 O(E)만큼 메모리 공간이 필요함
O(V) - 노드의 개수만큼 시간이 소요된다.
### ◾ 구현방법 2 : 인접 행렬 이용
- 구현방법, 특징, 시간/공간복잡도 등
2차원 배열을 사용하는 방식 
인접행렬은 간선의 정보를 저장하기 위해서 O(노드 제곱의 개수)만큼 메모리 공간이 필요함
특정한 노드 A에서 다른 특정한 노드 B로 이어진 간선의 비용이 O(1)이라는 시간으로 소요되는 장점이 있음
</br>

## 큐

### ◾ 개념

### ◾ 언어별 선언 및 사용방법(CRUD)

### ◾ 시간복잡도

### ◾ 장점

### ◾ 단점

</br>

## BFS (너비우선탐색 : Breadth First Search)

### ◾ 개념
가까운 노드부터 탐색하는 알고리즘    
선입선출 방식인 큐를 사용하는 것이 정석이다.   
과정을 보면 다음과 같다.   
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.   
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리를 한다.   
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.  
### ◾ 시간복잡도

### ◾ BFS와 DFS의 비교
DFS는 스택이라는 자료구조를 사용해서 동작하도록 함, 재귀함수를 이용해서 구현한다.  
BFS는 큐라는 자료구조를 사용해서 동작하도록 함, 큐를 이용해서 구현한다.   
### ◾ 코드
```
from collections import deque

#bfs메서드 정의
def bfs(graph,start,visited):
  queue = deque([start])
  visited[start] = True
  while queue:
    v = queue.popleft()
    print(v,end='')
    for i in graph[v]:
      if not visited[i]:
        queue.append(i)
        visited[i] = True
        
 graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
 ]
 
 
 visited = [False]*9
 
 bfs(graph,1,visited)
```

</br>


## 참고

(이해에 도움이 되는 그림이 있다면 어디에든 추가해주세요:))
