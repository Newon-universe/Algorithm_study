# 백트래킹이란
> 들어가기에 앞서서, 해당 글은 기본적인 문법 (for, while, print, 입력받기, 배열)에 대해서 알고 있음을 전제로 합니다.  
> 만약 기본적인 문법을 모르는 상태라면 반복문과 출력, 배열, 입력받기에 대해서 먼저 이해한 후 다시 찾아와주세요. :)  
  
> 설명에선 C언어와 Kotlin 을 섞어서 사용하고 있지만, 최대한 언어적 특징없이 기본적인 문법만 사용합니다.  
> 해당 내용은 호흡이 깁니다. 끊어서 본다면 1번 재귀함수 - 2번 DFS - 3번 백트래킹 순서로 끊어서 보는 것을 추천합니다.  

### 백트래킹 DFS 탐색 중 가지치기 하는 것.

`백트래킹`은 완전 탐색 방법 중 하나인 `깊이 우선 탐색(DFS)`을 진행하면서 조건을 확인,  
`해당 노드가 유망하지 않으면` 더 이상 탐색하지 않는 것을 의마한다.  
  
백트래킹은 일반적으로 재귀의 형태로 작성되며, 크게 다음의 3개 내용을 작성해야한다.   
- 재귀를 진행하는 동안 사용될 깊이(depth)를 매개변수로 넣기
- 재귀가 종료되는 시점에서 수행해야할 내용
- 재귀가 진행중이면 가지치기(백트래킹)할 내용
  
여기에 재귀함수를 편하게 돌리고 싶다면 재귀에 필요하지만 변하지 않는 변수들과 재귀에서 사용하는 배열들을 전역변수로 선언하면  
재귀함수의 매개변수가 깔끔해져서 편하다.  
  <br/>
  
코드로 확인해보자. [백준 N과 M(1) 문제](https://www.acmicpc.net/problem/15649)를 확인하면  
1 ~ N 까지의 숫자 중에서 M개를 중복없이 오름차순으로 출력하는 것이 문제이다.  
_코드는 C언어로 쓰였지만, 코드만의 특징없이 작성되었다._

```C
#include <stdio.h>
#include <stdbool.h>

int arr[10] = {0, };                              // 1부터 N까지이니, 마음편하게 10개의 배열을 선언하였다.
bool isusedArr[10] = {false,};                    // 해당 숫자의 중복 여부를 위해 사용했는지 안했는지를 파악할 같은 크기의 배열을 하나 더 선언했다.
int N;                                            // 재귀에서 사용하지만 그 숫자가 변하지는 않는 변수를 전역변수로 선언하였다.
int M;                                            // 재귀에서 사용하지만 그 숫자가 변하지는 않는 변수를 전역변수로 선언하였다.

void Solve(int k){                                // 재귀함수가 사용되는 동안 사용될 depth 를 여기선 k로 표현하고 있다. 
    if(k == M){                                   // 해당 재귀함수는 k가 계속 증가하며, k == M 일때 멈추는 구조를 가지고 있다.
        for (int i = 0; i < M; i++){              // 종료될 때, 수행해야할 내용은 "출력"이므로, 출력을 하고 있다.
            printf("%d ", arr[i]);
        }
        printf("\n");                             // 엔터를 출력하고 있다.
	return;                                   // 마지막에 수행해야할 내용들을 다 수행했으면 return 으로 함수를 종료한다.
    }
    
    for (int i = 1; i <= N; i++){                 // 재귀함수가 종료시점이 아니라면 for 문을 통해 재귀를 진행한다.
        if(!isusedArr[i]){                        // 가지치기할 내용을 찾고있다. 이번 같은 경우는 중복을 없애기 위해 다음과 같이 적용하고 있다.
            arr[k] = i;                           // arr[k] 에 i를 사용하고 있다.
            isusedArr[i] = true;                  // 사용하니까, 사용했음을 표시하고 있다.
            Solve(k+1);                           // 여기에서 재귀가 계속 반복되고 있다. k는 자릿수로 계속 증가하다가, k == M일 때 종료돨 것이다.
            isusedArr[i] = false;                 // 다음 DFS 를 위해 다시 사용하지 않았으로 바꿔주고 있다.
        }
    }
}

int main(){
    scanf("%d %d", &N, &M);                       // 함수의 시작이다. N과 M을 입력받고 있다.
    Solve(0);                                     // 재귀함수의 시작이다. 0부터 시작하고 있다.
}
```


코드를 크게크게 확인해보자  
- Solve 함수는 DFS 함수로 k를 기준으로 진행되고 있다.  
- Solve 의 맨 위에선 재귀가 종료될 시점에 출력을 하고 변경없이 return 으로 함수를 종료하고 있다.  
- Solve 의 밑 에서는 for 문을 통해 가지치기할 내용을 확인하고 있다.  
  `if(!isusedArr[i])` 를 통해 isusedArr이 0, 즉 사용하지 않은 숫자라면 재귀를 진행하고 있다.  
  세부적으론, `arr[k]` 에 i를 넣고있고, 해당 i를 사용처리 한 후 다음 재귀로 넘어가고 난 후 비사용으로 바꿔주고 있다.  
  

백트래킹은 위의 구조를 기본 골조로 하며, 조건의 추가 & 삭제, 혹은 해당 depth 의 사용, 미사용 등의 조합으로 사용된다.  
  
  <br/>
  

## 아 그래서 그게 뭔데 ㄹㅇㅋㅋ
<img src="https://user-images.githubusercontent.com/80164141/138657237-2fb8bf1f-2cd5-4a6e-9d84-3bd303c251d5.jpg" width="30%"/>

만약 당신이 위의 글만 보고서 **아 ! 백트래킹이란 저런거구나 ㅎㅎ 이해했어** 라면 이제 뒤로가기를 눌러도 좋다.  
이제부터 이 글은 철저하게 아무것도 모르는 문과생의, 문과생에 의한, 문과생을 위한 언어로 설명된다.  
  
우선 우리는 ① `재귀함수`가 무엇인지 정확하게 알 필요가 있다.  
그 다음으로 ② `DFS 함수`에 대해서 알아야 하며,  
최종적으로 DFS 를 진행할 때 ③ `가지치기(백트래킹)`을 어떻게 하는 지 알아볼 것이다.  
  <br/>
  
----- 
  
### 재귀함수가 뭔데
<img src="https://media.giphy.com/media/3ov9jQX2Ow4bM5xxuM/giphy.gif" width="30%"/>
<img width="600" alt="스크린샷 2021-10-25 오후 5 47 22" src="https://user-images.githubusercontent.com/80164141/138665281-c20aae33-e2ed-46ed-bd0b-59d95e4f289d.png">

재귀함수란 코드 내에서 자기 자신을 호출하는 함수를 의미한다.  
내가 나를 부르고, 다시 내가 나를 부르고, 틱X 이나 유튜브숏X에서 자주 보던 그것들이 맞다.  
  
프로그래밍적으로 재귀함수는 다음처럼 쓰인다.  
```Kotlin

fun DFS(N: Int){
    print("$N ")
    return DFS(N + 1);
}

fun main(){
    DFS(0)
}
```
위의 코틀린 함수를 확인해보자.  
main 함수에서 `DFS라는 함수`를, 0을 넣어서 호출하고 있다. ***함수 이름에는 우선 신경쓰지 말자*** 
`DFS 라는 함수`가 뭐하는 녀석인지 확인해보면, 우선 이녀석은 `N을 매개변수`로 받고 있다.  
이후 print("$N ") 을 통해서 N과 스페이스바를 출력하고, 종료할 때 자기 자신에 (N+1)을 넣은 것, `DFS(N + 1)` 을 호출하고 있다.  

그렇다면 이 재귀함수는 어떻게 작동할까?  
- DFS(0) 호출 - DFS(0)의 내용 수행 - 종료하면서 DFS(0 + 1) 호출   
- DFS(1) 호출 - DFS(1)의 내용 수행 - 종료하면서 DFS(1 + 1) 호출
- DFS(2) 호출 - DFS(2)의 내용 수행 - 종료하면서 DFS(2 + 1) 호출
- 무한반복
...  

와 같이 반복하게 된다.  
언제 끝날까? 영원히 끝나지 않는다. 왜냐하면 위의 함수는 자기자신을 호출하곤 있지만, 종료 조건이 없기 때문이다.  
따라서 위의 컴퓨터의 메모리가 허락할 때 까지 
`0 1 2 3 4 5 ... 백만스물하나 ... 백만스물둘... `  
을 출력하고 있을 것이다.  
  
위의 재귀함수를 다음과 같이 바꿔보자.
```Kotlin

fun DFS(N: Int){
    if(N == 11)
      return;
    
    printf("$N ")
    return DFS(N + 1)
}

fun main(){
    DFS(0)
}
```  

위의 코드와 차이점은 N이 11일 때, 아무것도 하지 않고 그냥 종료가 된다는 것이다.  
그럼 이 함수는 다음과 같이 작동한다.
- DFS(0) 호출 - N이 11인지 확인 - 11이 아님 - DFS(0)의 내용 수행 - 종료하면서 DFS(0 + 1) 호출
- DFS(1) 호출 - N이 11인지 확인 - 11이 아님 - DFS(1)의 내용 수행 - 종료하면서 DFS(1 + 1) 호출
- DFS(2) 호출 - N이 11인지 확인 - 11이 아님 - DFS(2)의 내용 수행 - 종료하면서 DFS(2 + 1) 호출
... 
- DFS(11) 호출 - N이 11인지 확인 - N이 11임 - 그냥 종료

if 문에서 N이 11일 때 종료하라는 내용을 통해서, 해당 재귀함수는 무한반복하지 않고 N이 11일 때 바로 종료하게 된다.  
따라서 위의 코드는 다음과 같이 출력하고 
`0 1 2 3 4 5 6 7 8 9 10`  
이후 함수가 종료된다.  
<br/>

if 문을 통해서 재귀함수가 종료될 조건을 단 것, 이것을 `Base Condition` 이라고 부른다.  
  
**재귀함수는 매개변수를 통해서 Base Condition 에 점차 다가가도록 설계하는 것이 원칙이다.**  
그래야 재귀함수를 안전하게 종료시킬 수 있기 때문이다.  
  
일반적으로 매개변수는 Base Condition 에 다가갈수만 있다면 증가해도, 감소해도 상관없지만 일반적으로 감소하도록 설계한다.  
  
사실 위의 코드는 굳이 재귀로 하지 않고, for 문으로도 쉽게 만들 수 있다.
```Kotlin
for(i in 0..10){
   print("$i ")
}
```
  
게다가 재귀함수는 for 문보다 훨씬 더 많은 메모리를 요구한다. 하나의 함수를 호출하는 것은 Stack 에 계속 쌓이며,  
보다 많은 메모리를 요구하며 속도 역시 훨씬 느리다.  
이러한 이유에도 불구하고 재귀함수를 쓰는 이유를 알아보자.  
