## 수학과 다이나믹 프로그래밍

### 소수
#### ◾ 개념
1보다 큰 자연수 중에서 약수가 1 또는 자기 자신인 수를 말한다. 1보다 크기 때문에 1은 제외다. 여담이지만 소수 중 짝수는 2뿐이다.

#### ◾ 기본 로직

```Kotlin
 fun main() {
    
    var num: Int = 3 // 소수인지 아닌지 알아보고 싶은 숫자 입력
    var flag: Boolean = true // 소수판별 플래그 (false면 합성수, true면 소수)
    
    while(true) {
        
        if (num == 2) {
            flag = true
        }
        
        for (i in num - 1 downTo 2) { // num으로 들어온 숫자를 제외(자기 자신 제외)하고 1씩 감소해서 2까지 모든 수로
            if (num % i == 0) { // num을 2 ~ num -1 까지의 수들로 각각 다 나눠봤을 때 '하나라도' 나눠 떨어지는 수가 걸린다?
                flag = false // 그럼 num 얘는 소수가 아님. (자기 자신 또는 1 말고는 그 어떤 수로도 나눠 떨어지면 안되기 때문)
                break
            }
        }
        
        if (flag == false) {
            println("소수가 아니다.")
        } else {
            println("소수다.")
        }
    }
    
}
```

#### ◾ 에라토스테네스의 체

1. 1보다 큰 자연수이므로 1은 제외
2. 2부터 어느 숫자까지 소수의 개수를 체크할건지, 숫자를 정한다.
3. 2는 소수조건을 충족, 3,5,7 도 충족
4. 2를 제외한 짝수는 모두 지운다. (2보다 큰 짝수는 다 2로 나눠지므로)
5. 홀수 중에서 3,5,7의 배수들도 모두 지운다. (배수를 지워주는 이유는 어떤 수든(소수라 할지라도) 자기 자신을 더하는 순간 2로 나눠지기 때문)
6. 2에서 정한 숫자까지 소수만 남게 된다.

```Koltin
 fun main() {
    val prime : Array<Boolean> = Array(1001) {true} // 1001 개의 배열을 선언하고 모든 배열을 boolean 값을 true로 초기화한다. ( 1001개를 하는 이유는 1~1000까지 소수인 수(true), 소수가 아닌 수(false)로 가려내어 소수가 몇개 있는지 가려내기 위해서인데, 배열 인덱스는 0부터 시작하므로 0~1000까지 1001개의 배열을 선언해줬다.)
    var count = 0 // 소수의 개수가 들어갈 변수
    var num = 0 // 1 ~ num 까지 소수가 몇개인지 체크하기 위한 입력 변수 (사실 하드코딩으로 입력해주는거지만)
    
    prime[0] = false
    prime[1] = false // 0과 1은 소수가 아니니까 false로 초기화

    for (i in 2..1000) { // 2 ~ 1000 까지 돌면서 체크
        if (prime[i]) { // i가 2일 때로 가정해보자
            for (j in 2 * i..1000 step i) { // 4 ~ 1000 까지 2씩 더해서 2의 배수 제거, 6 ~ 1000까지 3씩 더해서 3의 배수 싹 다 제거, 8 ~ 1000까지 4씩 더해서 4의 배수 싹 다 제거 ... 
               prime[j] = false // 2를 곱했기 때문에(2 * i) 2를 제외한 짝수는 다 걸러지고 (2보다 큰 짝수들은 다 2로 나눠지니까 소수에서 탈락), 어떤 홀수라도 자기 자신을 더하게 되면(step i) 무조건 2로 나눠지므로 다 탈락
            }
        }
    }
    // 소수의 배수들을 싹다 false 처리

    for (i in 0 until num){ // 그럼 0 ~ num 까지의 인덱스 배열 중
        if (prime[num] == true) { // true값을 가진 배열만 남게되는데 그 안에 들은 수들이 소수다.
          count++ // count 변수에서 집계
        }
    } // num의 개수만큼 반복문을 돌면서 그 안에 소수가 몇개인지 판별

    println(count) // 1 ~ num 까지 소수의 개수 출력

}
```

#### ◾ 시간 복잡도
> 기본 로직 = 대충 O(n2) 정도? n까지의 각 수를 그 n만큼의 시행으로 소수인지 아닌지를 체크하기 때문에 n의 제곱정도 복잡도에 근접한걸로 판단된다. 중복시행이 많기 때문에 효율적이지 않다.
> 에라토스테네스의 체 = O(Nlog(logN)) 그냥 존나 빠르다고 알면 된다.

</br>

### 다이나믹 프로그래밍
#### ◾ 개념

#### ◾ 조건  
**1. 첫번째 조건**  
> 첫번째 조건에 대한 설명  

**2. 두번째 조건**  

#### ◾ 메모이제이션(Memoization) 이란?

#### ◾ 분할 정복 방식과의 차이점

#### ◾ 기본 로직
**1. Top-down**  
> Top-down 방식을 짧막하게 서술하고,  
```java
 // 풀이 코드
```

**2. Bottom-up**  
> Bottom-up 방식을 짧막하게 서술하고,  
```java
 // 풀이 코드
```

</br>

### 참고
https://hanyeop.tistory.com/117
https://choheeis.github.io/newblog//articles/2020-04/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%EC%B2%B4
https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4


