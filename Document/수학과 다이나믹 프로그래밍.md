## 수학과 다이나믹 프로그래밍

### 소수
#### ◾ 개념
약수가 1 과 자기 자신 밖에 없는 수  
N이 소수가 되려면, 2보다 크거나 같고,  
N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.

</br>

#### ◾ 기본 로직

```java
boolean isPrime(int number) {
	if(number < 2) {                       /* 0 과 1 은 소수가 아니다 */
		return false;
	}

	if(number == 2) {                       /* 2는 소수다 */
		return true;
	}
		
	for(int i = 2; i < number; i++) {
		if(number % i == 0) {               /* 약수를 갖는 경우 종료 */
		    return false;
		}
	}

	return true;                           /* 위 반복문에서 약수를 갖지 않는다면 소수다 */
}
```

</br>

#### ◾ 에라토스테네스의 체

1. 2부터 N까지 모든 수를 써놓는다.
2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
3. 그 수는 소수이다.
4. 이제 그 수의 배수를 모두 지운다.
5. 남아있는 모든 수가 **소수**이다.

<p align="center"><img src="https://user-images.githubusercontent.com/48541984/135542109-d46727c2-6334-4fa9-81ac-3f47d4560615.gif" width="40%"/></p></br>

```java
boolean isPrime(int number) {
	boolean[] primes = new boolean[number + 1];
    primes[1] = true;
  
    for(int i = 2 ; i <= number ; ++i){
        if(primes[i]) continue;                      /* 소수가 아닌 (true) 수는 넘어가기 */
        for(int j = i + i ; j <= number ; j += i){  /* i를 제외한 i의 배수 모두 체크하기 */
    	primes[j] = true;
    }
  }
}
```
</br>

#### ◾ 시간 복잡도
* Basic `O(N)`
* Sieve of Eratosthenes `O(nloglogn)`

</br>

### 다이나믹 프로그래밍
#### ◾ 개념

#### ◾ 조건  
**1. 첫번째 조건**  
> 첫번째 조건에 대한 설명  

**2. 두번째 조건**  

#### ◾ 메모이제이션(Memoization) 이란?

#### ◾ 분할 정복 방식과의 차이점

#### ◾ 기본 로직
**1. Top-down**  
> Top-down 방식을 짧막하게 서술하고,  
```java
 // 풀이 코드
```

**2. Bottom-up**  
> Bottom-up 방식을 짧막하게 서술하고,  
```java
 // 풀이 코드
```

</br>

### 참고
[Java 소수 구하는 알고리즘 및 구현](https://st-lab.tistory.com/81)  
